# 5. CPU 성능 향상 기법
명령어 사이클은 클럭 신호에 따라 실행된다. CPU 속도를 빠르게 설계하고 싶다면 일단 간단한 방법은 클럭 속도를 빠르게 하는 것이다.
클럭 속도는 Hz 단위로 표시한다. 클럭 속도는 1초에 실행되는 클럭 사이클 수를 의미하는데 만약 1초에 한 번만 클럭이 실행되면 1Hz고 1초에 100번 클럭이 실행되면 100Hz인 것이다. 그러나 클럭 수를 증가시키면 발열도 증가하므로 하드웨어적인 한계가 존재한다. 이에 대한 대안으로는 코어를 여러 개 사용하는 것과 멀티 스레드를 활용하는 방법이 있다.

## 코어
CPU의 성능이 발전함에 따라 현대의 CPU라는 용어의 재해석 재해석이 필요했다. 과거에는 명령어를 실행하는 부품이 하나만 존재했다. 그러나 현대의 CPU는 성능 향상을 위해 명령어를 실행하는 부품을 여러 개 가질 수 있게 되었고 이러한 부품을 **코어**라고 하게 되었다.

![스크린샷 2023-08-20 224049](https://i.imgur.com/da52xFo.png)

위의 이미지와 같이 코어를 여러 개 가지고 있는 CPU를 **멀티코어 프로세서**라고 한다.

## 스레드
스레드는 실행되는 프로세스 내에서 독립적으로 실행되는 작업 단위를 말한다. 스레드는 크게 하드웨어 스레드와 소프트웨어 스레드로 분류할 수 있다.

### 하드웨어 스레드
하드웨어 스레드는 하나의 코어가 처리하는 명령어의 수를 나타낸다. 예를 들어, 하나의 코어가 한 번에 하나의 명령어를 처리할 수 있다면 이를 1코어 1스레드로 표현한다. 만약 두 개의 코어가 각각 두 개의 명령어를 동시에 처리할 수 있다면 2코어 4스레드로 표현한다. 이런 식으로 여러 개의 명령어를 동시에 처리하는 것을 멀티 스레드 프로세서 혹은 멀티스레드 CPU라고 한다. 이는 작업 흐름의 논리적인 단위를 나타내며, 따라서 논리 프로세서라고도 한다.

### 소프트웨어 스레드
소프트웨어 스레드는 하나의 프로그램 내에서 독립적으로 실행되는 작업 단위를 의미한다. 예를 들어, 워드 프로세서에서 사용자의 입력을 화면에 보여주는 작업과 동시에 맞춤법 검사를 시행하고 입력을 저장하는 작업을 동시에 실행하고 싶을 때, 각각의 스레드를 생성하여 병렬적으로 실행한다.

### 멀티스레드 프로세서
멀티스레드 프로세서를 설계하는 방법은 다양하지만 핵심은 레지스터다. 명령어를 실행하기 위해 필요한 레지스터를 여러 개 가질 수 있도록 구성하는 것이다. 예를 들어, 다음 실행할 명령어의 주소를 담는 프로그램 카운터가 두 개 있다면, 메모리에서 가져올 명령어의 주소를 두 개 지정할 수 있다. 이처럼 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU를 멀티스레드 프로세서라고 한다.

## 명령어 병렬 처리 기법
### 명령어 파이프라인
명령어 처리 과정을 클럭 단위로 나누어 보면 일반적으로 다음과 같이 나눌 수 있다.
1. 명령어 인출 (Instruction Fetch)
2. 명령어 해석 (Instruction Decode)
3. 명령어 실행 (Execute Instruction)
4. 결과 저장 (Write Back)
CPU는 이 단계가 겹치지만 않는다면 각 단계를 동시에 실행할 수 있다. 이렇게 단계를 나눠서 동시에 실행하는 방법을 **명령어 파이프라인**이라고 부르며, 이를 통해 처리 속도를 개선할 수 있다.

![스크린샷 2023-08-23 오전 12.04.20](https://i.imgur.com/juDfUla.png)

t<sub>1</sub>에는 명령어 1, 2를 동시에 실행할 수 있고 t<sub>2</sub>는 명령어 1, 2, 3을 동시에 실행할 수 있다.

하지만 파이프라인을 사용하더라도 항상 성능 향상이 되는 것은 아니다. 때로는 특정한 상황에서 문제가 발생하는데, 이를 **파이프라인 위험**이라고 부른다. 파이프라인 위험에는 크게 세 가지 유형이 있다.

#### 데이터 위험
명령어 간에 '데이터 의존성'으로 인해 발생한다. 쉽게 말하면, 이전 명령어의 결과가 필요해서 다음 명령어를 실행할 수 없는 경우에 일어난다. 예를 들어 아래와 같은 명령어 파이프라인이 있다고 해보자.

![스크린샷 2023-08-24 오후 7.40.58](https://i.imgur.com/5EJIurE.png)

명령어 1에는 R1 레지스터에 R2 + R3의 연산 결과를 저장하라는 명령어가 있고 명령어 2에는 R4 레지스터에 R1 + R5의 연산 결과를 저장하라는 명령어가 있다면 명령어 2를 실행하기 위해 명령어 1의 R1의 연산이 끝나야 하기 때문에 의존성이 생겼다고 할 수 있다.

#### 제어 위험
프로그램 카운터의 갑작스러운 변화에 의해 발생한다. Jump 명령어나 인터럽트가 발생하는 경우이다. 기본적으로 프로그램 카운터는 현재 실행 중인 명령어의 다음 주소가 저장되는데 실행 흐름이 갑자기 바뀌게 된다면 명령어 파이프라인에 미리 저장되어 있던 명령어들은 쓸모가 없어지는 것이다. 이를 방지하기 위해서 *분기 예측(branch prediction)이라는 기술을 사용한다.
*이전에 실행된 분기 결과를 토대로 가능성이 높은 분기 결과를 예측하는 기술

#### 구조적 위험
다른 명령어들이 동시에 같은 하드웨어 리소스를 사용하려고 할 때 발생한다. 자원 위험이라고도 부른다. 예를 들어 두 명령어가 같은 레지스터에 값을 저장하려 하는 경우이다.

### 슈퍼 스칼라
여러 개의 파이프라인을 가지고 있는 구조를 말한다. 각각의 파이프라인은 명령어를 여러 단계로 분리하여 동시에 실행시킬 수 있도록 설계되어 있어서 성능을 향상할 수 있다. 하지만 파이프라인이 늘어남에 따라 신경 써야 하는 파이프라인 위험이 늘어나기 때문에 슈퍼 스칼라 방식을 차용한 CPU는 고도로 설계되어야 한다.

## CISC와 RISC
RISC와 CISC는 명령어 집합(ISA)을 대표하는 두 개의 종류다.

### 명령어 집합
CPU마다 이해하는 명령어가 다르다. CPU가 이해할 수 있는 명령어 집합, 또는 구조를 ISA라고 한다. 대표적으로 x86 ISA, ARM ISA가 있는데 각각 인텔 노트북과 애플의 아이폰이 사용하는 ISA다. 서로의 실행파일을 다른 ISA에서 실행시키려고 하면 구동되지 않는데 그 이유는 실행파일은 명령어로 이루어져 있고 CPU마다 이해할 수 있는 명령어가 다르기 때문이다. 즉 같은 소스 코드라도 ISA가 다른 컴퓨터에서 컴파일하면 각각 다른 어셈블리어로 변환된다.

### CISC(Complex Instruction Set Computer)
영어 이름에서 알 수 있듯이 복잡한 명령어를 활용하는 CPU 설계 방식이다. x86, x96-64가 대표적인 CISC 기반의 ISA이다. 명령어의 형태와 크기가 다양하다 이것을 가변 길이 명령어라고도 한다. 명령어 하나하나가 강력한 기능을 제공하고 복잡하고 많은 수의 명령어가 존재한다. 그래서 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다. 예를 들어 하나의 소스 코드를 컴파일했을 때 x86은 상대적으로 적은 명령어들로 컴파일한다. 따라서 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았으나 명령어 파이프라이닝이 불리하다는 단점이 있다.

![스크린샷 2023-08-24 오후 6.49.09](https://i.imgur.com/cPWzceU.png)

파이프 라이닝이 잘되려면 위 그림처럼 실행되는 시간이 비교적 정형화 되어있어야 한다. 명령어 길이나 실행시간이 들쑥날쑥하지 않아야 명령어가 겹쳐서 실행하는 파이프라이닝이 잘 작동된다. 

![스크린샷 2023-08-24 오후 6.49.39](https://i.imgur.com/LmUZqBY.png)

CISC는 명령어가 다양하고 수행 시간이 길기 때문에 여러 클럭 주기를 필요로 한다. 따라서 파이프라이닝이 불리하다.

### RISC(Reduced Instruction Set Computer)
성능이 좋아지려면 파이프라인을 잘 활용해야 하고 파이프라인이 잘 작동되려면 정형화된 짧은 명령어가 효율적이다. 이러한 점을 수용하여 나온 CPU 설계 방식이 바로 RISC다. 대표적인 RISC 기반의 ISA는 ARM이 있다. 1클럭 주기로 실행되는 명령어를 지향하고 고정 길이 명령어 집합을 사용한다. 메모리 접근을 최소화하고 레지스터를 더 활용하기 때문에 일반적인 경우보다 범용 레지스터 개수가 많다. 이름에서 볼 수 있듯 RISC는 CISC에 비해 명령어 수가 적다. 그래서 같은 소스 코드를 컴파일하더라도 더 많은 명령어로 컴파일된다.

![스크린샷 2023-08-24 오후 7.12.11](https://i.imgur.com/zJZkdQN.png)

