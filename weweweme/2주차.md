# **Chapter 3: 명령어**

## **3-1. 소스 코드와 명령어**
모든 소스 코드는 컴퓨터 내부에서 명령어로 변환됩니다

## 고급 언어와 저급 언어
### 고급 언어(high-level programming language)
대부분의 프로그래밍 언어를 뜻합니다
### 저급 언어(low-level programming language)
컴퓨터가 이해하고 실행할 수 있는 명령어로 구성되어 있습니다

기계어와 어셈블리어로 분류됩니다
> 기계어(machine code) : 0과 1의 명령어 비트로 이루어진 언어
어셈블리어(assembly language) : 명령어를 읽기 편한 형태로 번역한 언어

<br>
 <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCbBb9%2FbtqUvDDBxH1%2FieF1PJ4JVqFNGtKMqLYpDk%2Fimg.png" alt="기계어와 어셈블리 어">

 [이미지 출처](https://wonin.tistory.com/24)
    
### 저급 언어를 알아야 하는 이유
프로그램의 실행 과정을 근본적인 단계에서부터 추적/관찰이 가능해집니다

## 컴파일 언어와 인터프리터 언어
언어가 변환되는 두 가지 방식이 존재하는데 각각 컴파일과 인터프리트입니다
### 컴파일 언어 : 컴파일 방식으로 동작하는 언어
컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어입니다

변환을 수행하는 도구를 컴파일러라 일컬으며, 이 컴파일러는 코드가 실행 가능한지, 오류는 없는지 검사하는 역할을 하며 이상이 하나라도 발견된다면 컴파일에 실패합니다

변환된 코드는 세컨더리 메모리에 저장됩니다

코드가 최적화 가능할 경우, 컴파일러는 추가적인 최적화를 수행합니다

컴파일이 성공적으로 수행되면 저급 언어로 변환되게 되는데 이렇게 변환된 코드를 목적 코드(object code)라 부릅니다

<br>
<img src="https://velog.velcdn.com/images/hunmok1027/post/20369d91-17cb-48de-9081-841486dab79d/image.png" alt="고급언어, 컴파일러, 저급언어">

[이미지 출처](https://velog.io/@hunmok1027/%EB%AA%85%EB%A0%B9%EC%96%B4)

### 인터프리트 언어 : 인터프리트 방식으로 동작하는 언어
소스 코드를 한 줄씩 차례로 실행하며 저급 언어로 변환하며, 이 변환을 수행하는 도구를 인터프리터라 합니다

소스 코드를 한 줄씩 실행하기 때문에 N번째 줄에 오류가 있더라도 N+1번 까지는 동작을 수행합니다

변환된 코드는 저장되지 않고, 프로세스에서 사용됩니다

컴파일의 결과물인 목적 코드는 저급 언어인 반면, 인터 프리터는 한 줄씩 해석하며 실행하기 때문에 상대적으로 느립니다

### 정리
현대의 많은 프로그래밍 언어는 반드시 둘 중 하나의 방식으로 동작하지 않습니다

고급 언어와 저급 언어로 변환되는 대표적인 방법에는 컴파일 방식과 인터프리트 방식이 있다 정도로 유연하게 받아들이는 것이 중요합니다
  
<br>
<img src="https://d8it4huxumps7.cloudfront.net/uploads/images/64b145126a0e8_1.jpg" alt="컴파일러와 인터프리터의 차이점">

[이미지 출처](https://unstop.com/blog/difference-between-compiler-and-interpreter)

## 목적 파일과 실행 파일
### 목적 파일
목적 코드로 이루어진 파일을 뜻합니다
### 실행 파일
실행 코드로 이루어진 파일을 뜻하며, .exe 파일이 대표적입니다
### 링킹
여러 목적 코드와 라이브러리 파일들을 하나의 실행 파일로 결합하는 과정으로, 정적 링킹(static linking)과 동적 링킹(dynamic linking)으로 나뉩니다
#### 정적 링킹
컴파일 시간에 수행되며, 필요한 모든 모듈이 결합된 형태. 외부 라이브러리에 의존하지 않아 단독 실행이 가능합니다
> ex. 유니티 프로젝트 내부의 Resources 폴더를 이용하여 에셋을 관리하는 상황
#### 동적 링킹
실행 시간에 수행되며, 필요한 라이브러리가 별도로 존재하며 실행 파일은 참조만 지니며 실행 중 라이브러리를 로드하여 사용이 가능합니다
> ex. AssetBundles을 이용해 에셋을 별도의 패키지로서 동적으로 관리하는 상황



## **3-2. 명령어의 구조**
## 연산 코드와 오퍼랜드
명령어는 '어떤 동작을 무엇을 대상으로 수행하라'의 구조를 지니고 있습니다

'어떤 동작을 수행하라' 라는 것은 연산 코드로 나타내며, '무엇을 대상으로' 라는 것은 오퍼랜드로 나타냅니다

이때 연산 코드를 연산자, 오퍼랜드를 피연산자라 표현하기도 합니다

<br>
<img src="https://velog.velcdn.com/images/thdgusrbek/post/4c71672a-30a5-4420-9a31-64ff0e1d9669/image.png" alt="연산 코드와 오퍼랜드">

[이미지 출처](https://velog.io/@thdgusrbek/%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EA%B5%AC%EC%A1%B0)

<br>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99F2153A5C10981023" alt="어셈블리 코드">
왼쪽 push, mov, sub 등은 연산 코드를 뜻하며 ebp, esp 등은 오퍼랜드를 뜻합니다

[이미지 출처](https://kanious.tistory.com/167)

### 오퍼랜드(operand)
데이터 자체보다 데이터가 저장된 위치가 적혀있으며, 메모리 주소 또는 레지스터가 적혀있습니다

주소 필드라는 이름으로도 불립니다

오퍼랜드는 0-3개 까지 존재할 수 있으며, 각각 0-3 주소 명령어라고 합니다

<br>
<img src="https://velog.velcdn.com/images/thdgusrbek/post/93c23bf3-825c-414f-bed1-ad875e8c2ffe/image.png" alt="오퍼랜드">

[이미지 출처](https://velog.io/@thdgusrbek/%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EA%B5%AC%EC%A1%B0)

### 연산 코드(operation code)
종류는 매우 많지만 크게 네 가지로 나뉩니다

> 아래와 같이, 연산을 알파벳 기호로 표기한 것을 [니모닉스(mnemonics)](https://en.wikipedia.org/wiki/Mnemonic)라고 하며, 니모닉스란 인간이 기억하기 쉬운 형태로 이름을 나타내는 기호를 뜻합니다
#### 데이터 전송
- MOVE : 데이터를 옮겨라
- STORE : 메모리에 저장하라
- LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
- PUSH : 스택에 데이터를 저장하라
- POP : 스택의 최상단 데이터를 가져와라
#### 산술 / 논리 연산
- ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
- INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
- AND / OR / NOT : AND / OR / NOT 연산을 수행하라
- COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
#### 제어 흐름 변경
- JUMP : 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT : 프로그램의 실행을 멈춰라
- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
#### 입출력 제어
- READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
- START IO : 입출력 장치를 시작하라
- TEST IO : 입출력 장치의 상태를 확인하라

## 주소 지정 방식(addressing mode)
오퍼랜드에는 다양한 방식으로, 데이터에 접근할 수 있는 방법을 제공합니다

다양한 방식을 사용하는 이유는, 명령어를 담는 바이트 중, 오퍼랜드를 위해 할당된 바이트는 한정되어 있기 때문입니다

따라서 오퍼랜드에는 사용할 데이터 자체, 데이터가 저장된 메모리 주소 혹은 레지스터가 담깁니다

연산의 대상이 되는 데이터가 저장된 위치를 유효 주소(effective address)라 합니다

현재 CPU는 다양한 주소 지정 방식을 사용합니다. 소개된 주소 지정 방식 외에도, 여러 방식이 존재합니다
### 즉시 주소 지정 방식(immediate addressing mode)
가장 간단한 형태의 오퍼랜드로, 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식입니다

표현할 수 있는 데이터의 크기가 작아지지만, 연산에 사용할 데이터를 바로 사용 가능해서 속도가 빠릅니다

<br>
<img src="https://velog.velcdn.com/images/thdgusrbek/post/83e7d99a-0310-467e-8e56-511f09fd1b9b/image.png" alt="즉시 주소 지정 방식">

[이미지 출처](https://velog.io/@thdgusrbek/%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EA%B5%AC%EC%A1%B0)

예시
> MOV AX, #5
AX 레지스터에 5를 저장

### 직접 주소 지정 방식(direct addressing mode)
오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식입니다

유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 이기때문에, 이 또한 표현할 수 있는 유효 주소에 제한이 있습니다

<br>
<img src="https://velog.velcdn.com/images/thdgusrbek/post/51ab02d7-df2a-4884-b511-b7384c4c557e/image.png" alt="직접 주소 지정 방식">

[이미지 출처](https://velog.io/@thdgusrbek/%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EA%B5%AC%EC%A1%B0)

예시
> MOV AX, [1000h]
메모리 주소 1000h에 저장된 값을 AX 레지스터에 복사

### 간접 주소 지정 방식(indirect addressing mode)
유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식입니다

표현할 수 있는 유효 주소의 범위가 더 넓어지며, 두 번의 메모리 접근이 필요하기 때문에 앞선 방식 보다는 느립니다

<br>
<img src="https://velog.velcdn.com/images/thdgusrbek/post/c6c221d3-413e-400b-aff6-76b0ccbb843e/image.png" alt="간접 주소 지정 방식">

[이미지 출처](https://velog.io/@thdgusrbek/%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EA%B5%AC%EC%A1%B0)

예시
> MOV BX, 1000h
MOV AX, [BX]
BX에 저장된 주소, 즉 1000h에 위치한 메모리 값을 AX에 저장

### 레지스터 주소 지정 방식(register addressing mode)
연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법입니다

CPU가 접근할 수 있는 메모리중 가장 빠른 메모리는 레지스터이며, 따라서 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있습니다

하지만 레지스터 크기에 제한이 있기 때문에, 데이터의 크기에 제한이 생길 수 있습니다

<br>
<img src="https://velog.velcdn.com/images/thdgusrbek/post/a39d01ad-ebb8-4a56-8357-a3dae1a781fc/image.png" alt="레지스터 주소 지정 방식">

[이미지 출처](https://velog.io/@thdgusrbek/%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EA%B5%AC%EC%A1%B0)

예시
> MOV AX, BX
BX 레지스터의 값을 AX 레지스터로 복사

### 레지스터 간접 주소 지정 방식(register indirect addressing mode)
연산에 사용할 데이터를 메모리에 저장하고, 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식입니다

메모리에 저장된 유효 주소에 접근하여 한번 더 유효 주소를 통해 필요한 데이터가 저장된 메모리로 향하는 간접 주소 지정 방식과 비슷하지만, 레지스터에 접근하는 것이 CPU 입장에서는 빠르기 때문에, 레지스터 간접 주소 지정 방식은 간접 주소 지정 방식보다 빠릅니다

<br>
<img src="https://velog.velcdn.com/images/thdgusrbek/post/6676cdc2-2f8a-4c1a-b4d6-a0383ce05f14/image.png" alt="레지스터 간접 주소 지정 방식">

[이미지 출처](https://velog.io/@thdgusrbek/%EB%AA%85%EB%A0%B9%EC%96%B4%EC%9D%98-%EA%B5%AC%EC%A1%B0)

예시
> MOV BX, [1000h]
MOV AX, [BX] 
BX 레지스터에 저장된 메모리 주소(1000h에서 가져온 값)에서 데이터를 읽어 AX에 저장

### 상대 주소 지정 방식(relative addressing mode)
오퍼랜드 필드에 프로그램 카운터(program counter; PC)와의 상대적인 거리 또는 오프셋(offset)을 지정하는 방식이며, 이 오프셋은 PC에 더해져서 실제 유효 주소를 얻습니다

이 방식은 주로 분기나 점프 명령에서 사용됩니다

<br>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20200830223820/PCRelativeMode.jpg" alt="상대 주소 지정 방식">

[이미지 출처](https://www.geeksforgeeks.org/difference-between-relative-addressing-mode-and-direct-addressing-mode/)

예시
> JMP +4
현재 명령어 위치에서 4바이트 뒤로 점프

### 인덱스 주소 지정 방식(indexed addressing mode)
특정 레지스터(인덱스 레지스터)의 값과 오퍼랜드 필드의 값을 더하여 유효 주소를 계산합니다

주로 배열이나 테이블에 대한 접근에 사용됩니다

<br>
<img src="https://cstaleem.com/wp-content/uploads/2020/07/Indexed-Addressing-Mode.png" alt="인덱스 주소 지정 방식">

[이미지 출처](https://cstaleem.com/types-of-addressing-modes)

예시
> MOV AX, [BX+4]
BX 레지스터 값에 4를 더한 주소의 메모리 값으로 AX 레지스터를 설정

### 자동 인덱싱 방식(auto-indexing mode)
명령어 실행 후에 자동으로 인덱스 레지스터의 값이 증가하거나 감소하는 방식입니다

이 방식은 연속된 메모리 위치에 접근할 때 유용합니다

<br>
<img src="https://cstaleem.com/wp-content/uploads/2020/07/Auto-Increment-Addressing-Mode-1024x562.png" alt="자동 인덱싱 방식">

[이미지 출처](https://cstaleem.com/types-of-addressing-modes)

예시
> LD R1, [R2+]
R2 레지스터에 저장된 주소의 메모리 값을 R1 레지스터에 로드하고, R2 값을 1 증가시킴


       
---

# 참고자료 
- [Understanding The Difference Between Compiler And Interpreter](https://unstop.com/blog/difference-between-compiler-and-interpreter)
- [CPU는 어떻게 작동할까?](https://www.youtube.com/watch?v=Fg00LN30Ezg&t=800s)
- [Addressing Modes](https://www.geeksforgeeks.org/addressing-modes/)
- [Types of Addressing Modes](https://cstaleem.com/types-of-addressing-modes)