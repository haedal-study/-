# 보조기억장치

오늘날 우리가 사용하고 있는 많은 컴퓨터들은 대량의 데이터를 저장하기 위해 HDD, SSD, 플래시 메모리등의 보조기억 장치를 활용한다. 이들에 대해 알아보자.

## 하드 디스크
**하드 디스크(HDD; Hard Disk Drive)** 는 자성을 이용하여 데이터를 저장한다. N극과 S극이 각각 0과 1의 역할을 대신한다.

### **하드 디스크 구성 요소**
하드 디스크는 LP판과 유사한 구조를 하고 있다. 구성 요소에 대해 알아보자. 이러한 구성 요소들의 상호작용이 하드 디스크의 접근시간 즉, 성능에 영향을 미치기 때문에 이들을 이해하는 것이 중요하다.

하드 디스크의 생김새는 아래와 같은데, 
![](https://velog.velcdn.com/images/invidam/post/f864011d-8f97-4800-a896-7ad5bdebe693/image.png)

실질적으로 데이터가 저장되는 원판을 **플래터**라고 하며, 원판을 회전시키는 요소를 **스핀들**이라고 한다.

#### **데이터 읽고 쓰는 요소**
이제 데이터를 읽고 쓰는 요소에 대해 알아보자.

![](https://velog.velcdn.com/images/invidam/post/c3809074-0bcb-4e16-9239-885bd7528b16/image.png)

데이터들은 헤드와 디스크 암에 의해 읽고 쓰인다. 헤드는 실질적으로 데이터를 읽는 부품이며, 디스크 암은 헤드를 원하는 위치로 이동시키는 부품이다. 이후 다루겠지만, 위치를 이동하는 방법이 접근 시간에 유의미한 영향을 미친다.

#### **하드 디스크 전송 단위**
플래터가 데이터를 전송하는 단위에 대해 알아보자.

![](https://velog.velcdn.com/images/invidam/post/69c73e7b-e518-4ac9-8119-a6f47a2b4108/image.png)

플래터는 여러 동심원으로 구성되어 있고, 그들 중 하나의 원을 트랙이라고 한다. 트랙을 여러 조각으로 나누었을 때 하나의 조각을 섹터라고 한다. 이 때 섹터가 디스크에 있어 가장 작은 전송 단위이다.

![](https://velog.velcdn.com/images/invidam/post/23a6b1f7-3936-413b-9deb-a6624b5780ba/image.png)

하드 디스크는 여러 겹의 플래터로 구성되어 있고, 같은 트랙 위치를 모아 실린더라고 한다. 실린더에는 연속된 정보를 보관하는데, 이는 같은 트랙 위치는 디스크 암을 움직이지 않고도 데이터에 접근할 수 있기 때문이다.

디스크 암을 움직이지 않는 것이 중요한 이유는 이러한 요소들이 데이터 접근 시간을 결정하기 때문이다.

### **데이터 접근 시간**
데이터 접근 시간은 크게 3가지로 나눌 수 있다.

1. 탐색 시간: 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
2. 회전 지연: 헤더가 있는 곳으로 플래터를 회전시키는 시간
3. 전송 시간: 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간

데이터 접근 요청을 어떤 순서로 할건지를 조정하여 성능을 향상시킬 수 있다.
일반적으로 현재 헤더위치와 가까운 요청부터 처리하여 성능 향상을 꾀한다.
자세한 내용은 [Disk Scheduling Algorithms](https://www.geeksforgeeks.org/disk-scheduling-algorithms/)를 참고하자.


### 기타
제프 딘이 2010년에 공개한 [프로그래머가 꼭 알아야 할 컴퓨터 시간들](https://gist.github.com/jboner/2841832)에 따르면,
하드 디스크 탐색 시간은 0.1초, 1MB를 순차적으로 읽는 시간은 0.3초로 조사되었다.

추가적으로 하드 디스크의 작동영상이 궁금하다면 [유튜브 링크](https://www.youtube.com/watch?v=BeBpXZpkiyg#t=1m43s)를 참고하자.

## 플래시 메모리
플래시 메모리(Flash memory)는 반도체 기반으로 전기를 이용하여 데이터를 저장한다. 하드 디스크와 비교하였을 때, 실린더를 회전하거나 암을 움직이는 동작이 없어 접근 속도가 빠르다. USB, SD카드, SSD를 비롯하여 ROM의 대체로도 사용되는 등 많은 전자 제품에 사용된다.

플래시 메모리는 근본적으로 마모 현상이 존재하여, 데이터 기록 횟수에 제한이 있다. 즉 수명이 존재한다. 이를 개선하기 위하여 데이터 접근을 골고루 하는 마모 평준화 기술을 이용하기도 한다.

### **플래시 메모리의 단위**
![](https://velog.velcdn.com/images/invidam/post/ebb2d2d2-7936-4802-9ada-436fb8f61ac9/image.png)

플래시 메모리는 셀 < 페이지 < 블록 < 플레인 < 다이 순서로 단위를 가지고 있다.

### **플래시 메모리 타입**
한 셀에 저장할 수 있는 비트 수에 따라 SLC, MLC, TLC, QLC 등으로 나뉜다. (각각 1,2,3,4 비트를 저장할 수 있다.)

| 구분 | SLC | MLC | TLC |
| --- | --- | --- | --- |
| 셀당 저장 가능한 bit | 1 | 2 | 3 |
| 수명 | 길다. | 보통. | 짧다. |
| R/W 속도 | 빠르다. | 보통. | 느리다. |
| 용량 대비 가격 | 높다. | 보통 | 낮다. |

상황(가격이 중요한지, 속도가 중요한지)에 따라 타입을 선택하며, 일반적인 컴퓨터에서는 MLC나 TLC를 사용한다.

실제 판매중인 SSD를 통해 TLC를 사용하는 것을 확인할 수 있다.
![](https://velog.velcdn.com/images/invidam/post/023d8a08-7a27-4ec8-9b64-8a161768f981/image.png)
(다나와에 나와있는 삼성전자 SSD 모습)

SLC 캐싱 기술이라고 하여, 캐싱을 이용해 TLC를 SLC처럼 사용하는 기술도 존재한다. 참고: [DRAM 캐시와 SLC 캐싱](https://www.manzlab.com/news/articleView.html?idxno=22744#:~:text=DRAM%20%EB%A7%B5%ED%95%91%ED%95%B4%EC%84%9C%20%EC%A0%81%EC%9A%A9%ED%95%9C%20%EA%B2%83%EC%9D%B4,%EB%A7%B5%ED%95%91%20%ED%85%8C%EC%9D%B4%EB%B8%94%EB%A1%9C%20%EC%A0%81%EC%9A%A9%ED%95%9C%EB%8B%A4.)

### **플래시 메모리 상태**
플래시 메모리는 Free, Valid, Invalid라는 3가지 상태를 가진다.

Free는 비어 있음을, Valid는 데이터가 저장되어 있음을 나타낸다. Invalid는 쓰레기 값을 나타내는데 이러한 상태가 굳이 존재하는 이유는 읽기, 쓰기 작업의 단위와 삭제 작업의 단위가 다르기 때문이다.

플래시 메모리는 읽기, 쓰기 작업은 블록 단위로 이루어지고 삭제 작업은 더 큰 단위인 페이지 단위로 이루어진다. 따라서 아래와 같이 A를 A'로 변경하고자 한다면, 덮어쓰기 & 삭제가 불가능하기에 A'를 저장하고 A를 Invalid 상태로 만들어 해결한다.

![](https://velog.velcdn.com/images/invidam/post/2b6b3119-c877-4f40-b285-29b574c82e31/image.png)

(Invalid 상태가 된 모습)

이렇게 존재하게 되는 Invalid 상태는 용량 낭비를 초래하며, GC(Garbage collection)에 의해 정리된다.

GC의 동작 방식은 아래와 같다.

![](https://velog.velcdn.com/images/invidam/post/82d1b594-d1f7-4be9-8930-6f7e6e6a30e1/image.png)

하나의 블록에서 유효한 페이지들만 복사하여 새로운 사본을 만든다. 데이터를 복사한 후 원본을 삭제하는 방법은 실제 Java의 Garbage collection의 Survivor 영역에 비슷한 방식이 적용되어 있기도 하다.

GC와 유사하게 SSD가 유휴상태일 때 Invalid 값들을 정리하는 TRIM이라는 동작도 존재한다.

참고: https://prod.danawa.com/info/?pcode=5834230

## RAID

RAID는 Redundant Array of Independent Disks의 약자로, 동일한 디스크 여러 개를 논리적으로 병렬배치하여 안정성이나 성능 향상을 꾀하는 방법이다. 구성 방법에 따라 여러 개의 종류가 있고 이는 레벨로써 분리한다.

### RAID 0
![](https://velog.velcdn.com/images/invidam/post/196e16f0-4111-43c5-b813-a4b50c9cfea5/image.png)

단순하게 데이터를 번갈아서 저장하는 방식이다. 번갈아가며 저장하기에 스트라이핑이라고도 불린다. (저장된 모습이 줄무늬와 비슷하기 때문이다.) 하나의 저장 장치에 저장하는 것보다 병렬적으로 접근할 수 있어 속도가 빠르지만, 구성하는 여러 디스크 중 하나의 디스크 고장이 전체 디스크의 고장으로 이어진다는 단점이 있다.

### RAID 1
![](https://velog.velcdn.com/images/invidam/post/ae4dbb12-b30d-4bf7-9899-a2ccfb8ae892/image.png)

복사본을 만들어 데이터 복구를 간단하게 하는 방식이다. 저장을 할 때, 복사본에도 데이터를 저장해야 하기 때문에 속도가 느리고, 용량이 증가한다는 단점이 있다.

### RAID 4 
![](https://velog.velcdn.com/images/invidam/post/3348e409-2d49-42c2-b850-94502fedd28a/image.png)

RAID 1과는 달리 별도 저장 장치에 원본과 동일한 복사본을 저장하지 않고, 오류를 검출하고 복구를 가능케하는 패리티 비트*를 저장하는 방식이다. 디스크에 데이터를 쓸 때마다 패리티 비트 디스크에 데이터를 써야한다. 이로 인해 패리티 비트 디스크에 병목 현상이 발생한다.

*패리티 비트: 사전적 의미로는 오류를 검출만할 뿐 복구는 하지 못하나, RAID에서는 복구도 가능하다.

### RAID 5
![](https://velog.velcdn.com/images/invidam/post/86254805-8fd0-4535-b9c4-d6e1115d0345/image.png)

패리티 정보를 하나의 디스크가 아니라 분산 저장하여 병목 현상을 해결한 방식이다.

### RAID 6
![](https://velog.velcdn.com/images/invidam/post/42d09f30-4e0e-4539-8303-daabdd70ce85/image.png)

패리티 정보를 2개 중복하여 저장함으로써 안정성을 높이는 방식이다. 다만, 데이터 저장시 두 개의 패리티 정보를 갱신해야 하므로 속도는 느리다.

### Nested RAID
여러 RAID Level을 혼합하는 방식이다.

![](https://velog.velcdn.com/images/invidam/post/e54f0b05-342e-4b32-8195-4c8b961bcac4/image.png)

위 그림은 RAID 0(스트라이핑)을 적용한 후, RAID 1(복사본 생성)을 적용한 **RAID 01**의 모습이다.

![](https://velog.velcdn.com/images/invidam/post/25898864-0cea-49a2-b3f0-5fa742c94584/image.png)

위 그림은 RAID 1(복사본 생성)을 적용한 후, RAID 0(스트라이핑)을 적용한 **RAID 10**의 모습이다.

RAID01 과 RAID10 모두 저장 용량과 성능은 동일하다. 단, 내결함성* 측면에서 다르다.

![](https://velog.velcdn.com/images/invidam/post/6af9367c-4d7f-4fd4-b4e1-87773fdb6b55/image.png)

RAID01의 경우 위와 같이 Disk 0번이 고장난 경우, 비교적 멀리 있는 Disk 2번에서 복구를 해야하는 반면,

![](https://velog.velcdn.com/images/invidam/post/1d7655a2-a631-4f7f-b57a-1180bd1aca83/image.png)

RAID10의 경우 위와 같이 근접한 Disk 1번에서 복구를 해야할 수 있어 내결함성이 높아, RAID01 보다는 RAID10을 주로 사용한다.

### 결론
각 RAID 레벨마다 장단점이 있으며, 상황(안정성이 중요한지, 속도가 중요한지, 가격이 중요한지, 용량을 얼마나 사용할 수 있는지 등)에 따라 여러 선택을 해야한다.

# 입출력장치
여태까지 연산, 저장 장치들에 대해 알아보았다. 이러한 장치들은 대부분의 컴퓨터에 공통적으로 포함되어있다. 그렇다면 공통적으로 포함되어 있지 않는 장치들은 무엇이 있고 어떻게 처리하고 있을까? 이에 대해 알아보자.

**입출력장치**는 컴퓨터 내부와 외부 간 통신을 할 수 있는 장치이다. 모니터, 키보드, 마우스 스피커 등 다양한 장치들이 존재하며 보조기억장치도 포함되기도 한다.

이러한 다양한 장치들이 컴퓨터 내부와 연결하기 위해선 장치 컨트로러와 장치 드라이버가 필요하다.

## 장치 컨트롤러
![](https://velog.velcdn.com/images/invidam/post/68ba7d7f-388c-4887-ad5f-f86bba3b34af/image.png)

(장치 컨트롤러의 모습)

장치 컨트롤러는 입출력 장치와 CPU 사이에 존재하는 하드웨어이다. 장치 컨트롤러는 입출력장치의 많은 종류를 CPU에 상호작용할 수 있도록 하고 CPU와 입출력 장치 간의 전송률 차이를 완화하는 역할을 한다.

### 장치 컨트롤러의 기능
장치 컨트롤러는 CPU와 입출력 장치 사이에서 통신을 중개하며 CPU가 다양한 입출력 장치가 아닌 장치 컨트롤러 하나만 알고있으면 되도록 하였고, 중개 과정속에서 입출력 장치의 오류 또한 검출할 수 있다. 마지막으로, 데이터를 버퍼를 이용하여 전송률 차이를 완화하였다.

버퍼는 대량의 데이터를 모은 후 소량씩 여러 번 내보내거나, 소량의 데이터를 모은 후 대량으로 내보낼 수 있다. 전송률이 높은 CPU에서 들어온 대량의 데이터는 입출력 장치에게 소량으로 여러 번 입출력 장치에게 내보내고, 전송률이 낮은 입출력 장치에서 들어온 소량의 데이티는 모았다가 대량으로 CPU에게 내보내어 전송률 차이를 완화한다.

### 장치 컨트롤러의 구성
장치 컨트롤러는 데이터 레지스터, 상태 레지스터, 제어 레지스터로 구성되어 있다. 
- 데이터 레지스터: 데이터가 담기는 레지스터이다. 버퍼 역할을 하며 RAM을 대신 사용하기도 한다.
- 상태 레지스터: 입출력 장치의 준비 & 완료 & 오류 없음 등의 다양하 상태를 저장한다.
- 제어 레지스터: 입출력 장치가 수행할 제어(명령)을 저장한다.

## 장치 드라이버
![](https://velog.velcdn.com/images/invidam/post/c65b2ea9-a7e9-4b46-b87f-80a0f959c688/image.png)

(장치 드라이버 - 장치 컨트롤러 - 입출력장치의 구성)

장치 컨트롤러가 하드웨어적인 구성요소라면, 장치 드라이버는 소프트웨어적인 구성요소이다. 장치 컨트롤러가 CPU와 상호작용을 할 수 있도록 하는 프로그램이다.

일반적으로 운영체제에 의해 제공되며, 일부 입출력 장치의 장치 드라이버는 제조사에서 직접 제공하기도 한다.

## 다양한 입출력 방법
장치 드라이버에 의해 CPU와 장치 컨트롤러가 상호작용을 한다고 배웠다. 이번에는 이러한 상호작용이 일어나는 방법 3가지에 대해 알아보자.

### 1. 프로그램 입출력
프로그램 입출력 방법은 명령어로 입출력장치를 제어하는 방법이다. CPU가 입출력 명령어를 제어 컨트롤러에게 내려 진행된다.

데이터를 보조기억장치(입출력 장치)에 저장하는 예시를 통해 살펴보자.

1. CPU가 장치 컨트롤러의 제어 레지스터에 쓰기 명령을 보낸다.
2. 장치 컨트롤러는 이를 읽고 장치를 확인 후 상태 레지스터를 갱신한다.
3. CPU가 주기적으로 상태 레지스터를 확인하며, 준비 완료 상태가 되었음을 파악한다.
4. CPU가 데이터 레지스터에 데이터를 쓴다.
5. 장치 컨트롤러가 이를 하드 디스크에 저장한다.

이 때, CPU가 장치 컨트롤러의 레지스터들을 인식하는 방법은 2가지가 있다.

#### 메모리 맵 입출력
메모리 주소 공간을 메모리를 위한 공간과 입출력 장치에 접근하기 위한 공간으로 나누어 간주하는 방법이다. 메모리를 위한 명령어로 입출력 명령까지 처리할 수 있어 간단한 명령 구조를 사용한다. 하지만, 메모리와 같은 버스를 사용하기에 성능에 악영향이 있을 수 있다.

#### 고립형 입출력
메모리 주소 공간과 입출력 장치의 주소 공간을 분리하는 방법이다. 다른 주소 공간 & 버스를 사용하기에 속도도 빠르며, 공간 효율도 뛰어나다. 포트 맵 입출력이라고도 불린다.

### 2. 인터럽트 기반 입출력
CPU가 장치 컨트롤러의 상태 레지스터를 일일이 확인하지 않고, 제어 레지스터에 명령만을 내린 후, 장치 컨트롤러에서 작업이 완료된다면 인터럽트 요청을 날리는 방식이다. 장치 컨트롤러가 인터럽트를 날리기 전까지 CPU는 다른 작업을 할 수 있다.

![](https://velog.velcdn.com/images/invidam/post/eff2089a-0a52-466e-814e-ec1cf4ce306e/image.png)

(순차 처리되는 모습)

플래그 레지스터의 인터럽트 비트가 비활성이 된 경우는 위와 같이 여러 인터럽트들을 순차적으로 처리한다.

![](https://velog.velcdn.com/images/invidam/post/0937adc1-837e-47a1-b3bf-271eb35a9d57/image.png)

(A 실행 도중에 B가 처리되는 모습)

인터럽트 비트가 활성화 되어 있고 새로 들어온 인터럽트가 우선순위가 높은 경우, 인터럽트가 NMI인 경우는 위와 같이 기존 인터럽트를 멈추고 새로 들어온 인터럽트부터 처리할 수 있다. 첫 번째 경우는 PIC에 의해 처리된다.

![](https://velog.velcdn.com/images/invidam/post/d46c79ba-27ee-41ac-ba6b-97e7fea4fed3/image.png)

(PIC의 모습)

PIC는 Pogrammable Interrupt Controller의 약자로 장치 컨트롤러로부터 여러 인터럽트 요청을 받아들인 후, 우선순위에 맞게 CPU에 인터럽트 요청 신호와 인터럽트 벡터를 보내는 역할을 한다. 이를 통해 많은 인터럽트를 관리할 수 있다. 수많은 장치들의 인터럽트를 관리하기 위해 계층적으로 구성하기도 한다.

### 3. DMA(Direct Memory Access) 입출력
CPU가 다른 작업에 집중할 수 있도록, CPU를 대신하여 메모리나 장치 컨트롤러와 상호작용하고 작업 완료시 CPU에 인터럽트 요청을 날리는 방식을 DMA, 이 때 사용되는 물리적 장치를 DMA 컨트롤러라고 한다.

동작 방식은 아래와 같다.

1. CPU로부터 정보(입출력 장치의 주소, 연산, 연산할 메모리의 주소 등)와 함께 입출력 작업을 명령 받는다.
2. 장치 컨트롤러와 상호작용하여 입출력 작업 수행한다.
3. 작업 이후 CPU에게 인터럽트를 통해 작업 완료를 알린다.

CPU를 대신하여 장치 컨트롤러와 상호작용하여 CPU에 부담을 줄여주려는 목적하에 등장하였지만 , 동시 사용이 불가능한 시스템 버스를 CPU와 같이 사용한다는 문제가 있다. 이는 최대한 CPU가 사용하지 않을 때 시스템 버스를 사용하거나, 일시적으로 허락을 구하고 시스템 버스를 사용하여 해소한다. 이러한 행위를 **사이클 스틸링**이라고 부른다.

장치 컨트롤러와의 상호작용도 시스템 버스에서 일어나기 때문에, 별도 버스인 입출력 버스를 이용하여 시스템 버스의 사용 빈도를 줄이기도 한다. 대부분의 현대 컴퓨터는 입출력 버스가 갖춰져 있고, PCI 버스, PCIe 버스 등으로 불린다.

### 기타

입출력 방식 선택 역시 상황마다 다르다. 하지만, 일반적으로 DMA를 사용하는 것이 효율적이라고 하며, 아주 작은 시스템에서는 프로그램 입출력방식을 고려한다고 한다.


## 참고
- 보조기억장치 이미지: https://www.youtube.com/watch?v=m2NfFJEvssY&list=PLVsNizTWUw7FCS83JhC1vflK8OcLRG0Hl&index=20
- RAID
  - nested raid image: https://en.wikipedia.org/wiki/Nested_RAID_levels
  - raid01 vs raid10: https://www.thegeekstuff.com/2011/10/raid10-vs-raid01/
  - EC2 Linux에서 RAID 적용법: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/raid-config.html
- [인터럽트 이미지](https://www.youtube.com/watch?v=RRgGVu8OCP4&list=PLVsNizTWUw7FCS83JhC1vflK8OcLRG0Hl)
- [PIO vs Interrupt vs DMA](https://www.quora.com/Is-the-Direct-Memory-Access-DMA-better-than-Programmed-I-O-and-Interrupts-driven-I-O-If-yes-then-how-If-no-then-which-one-is-better-and-in-which-scenario)
