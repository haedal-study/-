# CPU의 동작원리
컴퓨터의 핵심 부품중 하나인 CPU(Central Processing Unit)는 처리(연산)을 담당하는 장치이다. 컴퓨터에서 연산은 가장 핵심적인 기능이며, 이를 잘 알게된다면 컴퓨터의 여러 시스템을 수월하게 이해할 수 있고, 프로그램 개발에 응용할 수 있을 것이다.

## ALU와 제어장치
이러한 연산을 제공하기 위해 CPU는 ALU와 제어장치(CU;Control Unit)을 이용한다.

### ALU
ALU는 연산을 수행하는 주체이다. **입력**으로는 제어장치에서 제어신호를, 레지스터에서 피연산자를 받는다. 출력으로는 레지스터에 연산결과를, 플래그 레지스터에 추가적인 상태정보를 내보낸다. 연산을 "**입력**을 정해진 규칙에 따라 **조작**하여 **출력**하는 행위"로 정의해본다면 피연산자는 입력, 조작하는 행위는 제어신호, 연산결과와 추가적인 상태정보는 출력이 될 것이다.

CPU는 여러 출력값들을 메모리에 비해 상대적으로 접근속도가 빠른 레지스터에 저장하여 빠른 연산처리를 할 수 있다.

이러한 출력값을 레지스터에 저장하는 이유는 메모리에 비해 상대적으로 접근속도가 빨라 빠르게 연산을 처리할 수 있도록 도움을 주기 때문이다.

### 제어장치
제어장치는 명령어를 해석하고, 다른 부품들에게 제어신호를 통해 명령을 내린다. 총 4가지의 입력을 받아 동작하는데 이는 다음과 같다.


1. 클럭신호: 다른 장치들처럼 클럭 신호에 맞춰 동작한다.
2. 해석해야할 명령어: 명령어 레지스터로부터 해석해야하는 명령어를 입력받아 이를 바탕으로 신호를 발생시킨다.
3. 플래그 값: 플래그 레지스터로부터 플래그 값을 입력받아 신호를 발생시킬 때 참고한다.
4. 제어 신호: 제어버스로부터 CPU의 내부와 외부에서 신호를 받아들인다. 또한 이들에게 신호를 내보내기도 한다.

## 레지스터
레지스터는 연산에 들어갈 입력, 연산의 결과 등을 저장하기 위해 사용한다. 중요한 레지스터 8가지에 대해 알아보자.


1. 프로그램 카운터
다음에 실행할 명령어의 주소를 저장한다. 프로그래밍 언어의 `break`, `function()`, `for` 등에 의해 순차적이지 않은 주소가 저장되기도 한다. 자바 가상머신에서도 다음에 실행할 명령어의 위치를 기억하기 위해 동일한 이름의 저장공간을 사용한다.
    - *무언가를 가리킨다는 의미에서 배열의 인덱스와 유사하다.*
2. 명령어 레지스터
읽어들인 명령어를 저장한다; 이는 추후 제어장치에게 전달된다.
3. 메모리 주소 레지스터
주소 버스를 통해 값의 주소를 저장한다. 
    - 읽기 작업을 할 주소 혹은 (메모리에) 쓰기 작업을 하려는 데이터의 주소가 저장된다.
    - *주소를 저장한다는 의미에서 포인터와 유사하다.*
4. 메모리 버퍼 레지스터
데이터 버스를 통해 값을 저장한다.
    - 읽기 작업의 결과물 혹은 (메모리에) 쓰기 작업을 수행하기 위한 일시적인 값을 저장한다.
    - *값을 저장한다는 의미에서 일반 변수와 유사하다.*
5. 플래그 레지스터
ALU에서 처리한 연산의 부가정보를 저장한다.
6. 범용 레지스터
정해진 용도가 있는 전용 레지스터들과 달리 다양한 용도로 활용되는 레지스터이다.
    - x86 프로세서 기준으로 `EAX, EBX, ECX, EDX, EBP, ESP` 등이 해당된다.
    - 참고: [x86 Assembly/X86 Architecture](https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture)
7. 스택 포인터
스택 주소 지정 방식에서 스택의 최상단에 적재되어있는 데이터의 주소를 가리킨다.
8. 베이스 레지스터
베이스 레지스터 주소 지정 방식에서 기준점이 되는 주소를 저장한다.

### 스택 주소 지정 방식
주소 지정 방식 중 하나이며 임시변수, 함수 복귀 주소를 비롯한 호출된 함수에 대한 정보를 저장하는 스택 공간에서 사용한다. 함수 호출시 정보들이 스택 공간에 push되며 함수 종료시 pop된다. 

#### **함수 호출과 리턴**

**용어 정리**

EIP: 다음 실행할 명령어가 저장된 레지스터

EBP: 함수의 시작 지점이 저장된 레지스터

ESP: 스택의 맨 위가 저장된 레지스터

**함수 실행 이전 (프롤로그)**

1. push ebp: caller 함수 시작 위치를 가져온다. (추후 복귀에 사용된다.)
2. move ebp esp: 현재 스택의 위치를 callee 함수의 시작 위치로 지정한다.

**함수 리턴 (에필로그)**

1. move esp ebp: caller 함수의 ebp를 esp로 바꾼다.
2. pop ebp: 저장된 ebp 값으로 복원한다.
3. ret: 함수 종료 및 반환한다.

**참고**

- https://sy99.tistory.com/13
- https://allblackk.tistory.com/89

### 변위 주소 지정 방식
오퍼랜드 필드를 이용하여 주소를 지정하는 방식이다. 
레지스터의 값과 오퍼랜드의 변위를 더하여 주소를 결정하는 방식을 **상대 주소 지정 방식**이라고 하며, 레지스터의 값을 기준 주소로 한 후 오퍼랜드를 통해 특정 거리만큼 이동하여 주소를 결정하는 방식을 **베이스 레지스터 주소 지정 방식**이라고 한다.


## 명령어 사이클과 인터럽트
### 명령어 사이클
CPU는 정해진 절차에 따라 명령어를 실행한다. 이 때 정해진 절차를 명령어 사이클이라고 한다. 명령어 사이클은 메모리에 있는 명령어를 CPU로 가져오는 단계인 인출 사이클, 가져온 명령어를 실행하는 실행 사이클로 구성된다. 또한, 주소를 참조하기 위해 추가적으로 발생하는 사이클을 간접사이클이라고 한다.

### 인터럽트
CPU는 동작 중에 실행중인 작업을 중단하고 다른 작업을 실행하는 경우도 있다. 이를 발생시키는 신호를 인터럽트라고 한다. 인터럽트는 CPU 내 오류로 인해 발생하는 동기 인터럽트(예외)와 입출력장치로부터 발생하는 비동기 인터럽트 (하드웨어 인터럽트)로 나뉜다.

**동기 인터럽트**
동기 인터럽트는 폴트, 트랩, 중단, 소프트웨어 인터럽트로 구성된다.
- 폴트: 예외 발생한 명령부터 처리하는 예외이다.
- 트랩: 예외가 발생한 이후 명령부터 처리하는 예외이다.
- 중단: 복구할 수 없는 예외가 발생하여 프로그램을 중단할 수 밖에 없는 예외이다.
- 소프트웨어 인터럽트: 시스템 콜 호출로 인해 발생하는 예외이다.

**비동기 인터럽트**
비동기 인터럽트가 발생할 경우
1. 입출력 장치에서 CPU에게 인터럽트 신호를 전송한다.
2. CPU는 인터럽트가 발생과 인터럽트 플래그 확인을 통해 인터럽트를 처리할 것인지를 결정한다.
3. 처리하게 된다면, CPU내에 하고있던 작업을 저장(context saving)한다.
4. 이후 인터럽트 벡터를 참고하여 인터럽트 서비스 루틴을 실행한다.
5. 서비스 루틴이 끝난 후 저장된 작업을 복구(context restore)한다.
