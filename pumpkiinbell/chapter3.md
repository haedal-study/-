# 3. 명령어

## 3.1 소스 코드와 명령어

### 고급 언어와 저급 언어

고급과 저급 언어를 나누는 기준은 **컴퓨터의 이해, 실행 가능 여부**이다.

### 컴파일 언어와 인터프리터 언어

고급 언어를 저급 언어로 변환하는 방식은 크게 두 가지가 있다.

- 컴파일 언어는 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어이다.
  - 이 과정을 컴파일이라고 하며, 컴파일을 수행하는 도구를 컴파일러라 부른다.
  - 대표적으로 C 가 있다.
- 인터프리터 언어는 소스 코드가 한 줄씩 실행되는 언어이다.
  - 소스 코드를 한 줄씩 실행하기에 N 번쨰 줄에 문법 오류가 있어도 N-1번째 까지는 올바르게 수행된다.
  - 대표적으로 Python 이 있다.
- 특징
  - 일반적으론 인터프리터 언어는 컴파일 언어보다 느리다.
  - 이 둘을 칼로 자르듯이 구분할 순 없다.

**(안중요) JS, TS 관련 잡다한 얘기...**

- JS 는 기본적으로 인터프리터 언어입니다.
  - 태초의 JS 는 웹 문서 구조의 동적인 표현을 위한 간단한 스크립트였으므로, 굳이 컴파일을 할 필요는 없었습니다.
  - 물론 JS 엔진에선 이를 기계어로 변환하는 과정을 거치지만, 특정 파일로 변환하진 않기에 인터프리터 언어라 취급할 수 있습니다.
- 그러나, 웹이 페이지가 아닌 애플리케이션으로서의 역할로 확장함에 따라 인터프리터 언어는 한계가 있었습니다.

  - 결정타로 Google Maps와 함께 등장한 V8 엔진으로 인해 지금은 다소 모호해졌습니다.
  - V8 엔진은 대부분의 컴파일러와 비슷하게, V8 엔진도 파싱, AST 구성, Byte Code 변환등의 작업을 합니다.
    - ![example](https://velog.velcdn.com/images/seungchan__y/post/7f97490e-90a5-47ca-87a0-b1d3c754a850/image.png)
    - 다만 일반적인 컴파일러와는 약간 다르게, 인터프리터를 모니터링 하다 반복 실행 코드를 발견하면 최적화 바이트 코드를 만들게 됩니다.
      - 이와 같이 필요할 때마다 컴파일을 하는 컴파일러를 **JIT(Just-In-Time) 컴파일러**라 합니다.

- JIT Compiler

  - 인터프리터 언어 구현의 성능 향상을 목적으로 도입하는 경우가 많습니다.
  - 같은 코드를 매번 해석하는 대신, 처음 실행될 때 자주 쓰이는 코드를 캐싱하고 이후엔 캐싱 코드를 가져다 쓰게 됩니다.
  - 단점은 실행 단계에서 초기 컴파일 시 정적 컴파일 프로그램에 비해 속도 면에서 손해를 본다는 점입니다.

- TypeScript 는 컴파일러가 달려 있습니다.
  - 이 컴파일러를 거친 결과물은 JavaScript 입니다. (Emit 을 하지 않고 타입 체킹만 하는 케이스도 잦긴 합니다.)
  - TypeScript 또한 Parser, AST 를 구성하며 이를 기반으로 타입 체킹을 하게 됩니다.
    - Scanner 가 소스 코드를 읽으며 Tokenizing 을 하고,
    - Parser 가 토큰을 읽어들이며 AST 를 만듭니다.
    - 이후 Binder 가 트리를 훑으며 구문 트리가 가진 노드들의 문맥, 타입 데이터 등을 수집합니다.
    - 이를 기반으로 Type Checking 을 하며,
    - 컴파일 오류가 나지 않는 경우 사용자 정의 tsconfig 파일을 기반으로 JavaScript 파일을 Emit 합니다.

### 목적 파일 vs 실행 파일

- 목적 파일: 컴파일러에 의해 컴퓨터가 이해하는 저급 언어로 변환된 코드로 이루어진 파일을 일컫는다.
- 실행 파일: 실행 코드로 이루어진 파일을 일컫는다.
- 특징
  - 목적 코드가 실행 파일이 되기 위해선 **링킹**이라는 작업을 거쳐야 한다.

## 3.2 명령어의 구조

### 연산 코드와 오퍼랜드

명령어를 구성하는 요소는 다음과 같다.

- 연산 코드: 명령어가 수행할 연산 (a.k.a 연산자)
- 오퍼랜드: 연산에 사용할 데이터 (a.k.a 피연산자)
  - 오퍼랜드 필드에는 숫자와 문자를 나타내는 데이터 또는 메모리, 레지스터 주소가 올 수 있다.
  - 그러나, 효율적인 메모리 사용을 위해 대부분 메모리 주소나 레지스터 이름이 담긴다.
    - 때문에 주소 필드라고도 부른다.

### 주소 지정 방식

- 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치를 **유효 주소**, effective address 라고 한다.
- 주소 지정 방식은 대표적으로 다섯 가지가 존재한다.
  - 즉시 주소 지정 방식 (immediate addressing mode) => **연산에 사용할 데이터**를 직접 명시
  - 직접 주소 지정 방식 (direct addressing mode) => 오퍼랜드 필드에 **유효 주소**를 직접 명시
  - 간접 주소 지정 방식 (indirect addressing mode) => **유효 주소의 주소**를 오퍼랜드 필드에 명시
  - 레지스터 주소 지정 방식 (register addressing mode) => 직접 주소 지정 방식과 비슷하게 **레지스터**를 오퍼랜드 필드에 명시
  - 레지스터 간접 주소 지정 방식 (register indirect addressing mode) => 연산에 사용할 데이터를 **메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터**를 오퍼랜드 필드에 명시
