# 3. 명령어   
---
## 3-1. 소스코드와 명령어   
### 1) 고급 언어와 저급 언어   
* 프로그래밍 언어 : 고급 언어와 저급 언어로 구분   
#### (1) 고급 언어   
* 사람이 이해하고 작성하기 쉽게 만들어진 언어   
  * c, c++. Java, Python 등   
* 컴퓨터는 이를 그대로 이해할 수 없다.   
#### (2) 저급 언어   
* 컴퓨터가 직접 이해하고 실행할 수 있는 언어   
  * 기계어, 어셈블리어   
* 명령어로 구성   
* 고급 언어로 작성된 소스코드는 반드시 저급 언어로 변환 필요   

##### <기계어>   
* 0과 1로 이루어진 비트 조합의 명령어 모음   
* 오로지 컴퓨터를 위해 만들어진 언어라 의미 파악 어려움   

##### <어셈블리어>
* 기계어를 읽기 편한 형태로 번역한 언어   
* 니모닉 기호를 사용하여 연산 과정을 단어화
  * ADD, SUB, JUMP 등

  * 아래 C#으로 작성한 코드의 어셈블리와 메모리 형태    
  
> ```cs   
>  class Program   
>  {   
>    static void Main()
>    {   
>      int a = 10;   
>      int b = 20;   
>      Console.WriteLine(a + b);    
>    }
> ```
> ![](https://velog.velcdn.com/images/cheeeedy/post/5a8f37c7-845f-48fc-b66d-8fc4a998c935/image.png)   
> 어셈블리어도 한눈에 파악하기 어렵다는 것을 알 수 있다.   

---
### 2) 컴파일 언어와 인터프리터 언어

* 고급 언어의 저급 언어 변환 방식
* 명확하게 구분 가능한 언어도 있지만 현대의 많은 언어는 경계가 모호

#### (1) 컴파일 언어   
* `컴파일 (Compile)` :  컴파일 언어로 작성된 소스 코드 전체가 저급 언어로 변환되는 과정
  * 컴파일 과정에서 문법 적 오류, 실행 가능 여부, 불필요한 코드 파악
* 컴파일러 (Compiler) : 위 컴파일 과정을 수행하는 도구
* 컴파일 언어 : 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환 이후 실행
  * C, C\+\+ 등   
* `목적 코드 (Object Code)` : 컴파일러를 통해 저급 언어로 변환된 코드
  
#### (2) 인터프리터 언어   
* `인터프리터 (Interpreter)` : 소스 코드를 한 줄씩 변환하는 도구   
  * Python 등   
* 컴파일 언어와의 비교   
  * 전체를 변환하는 대기 시간 불필요   
  * 오류가 있으면 실행이 불가능한 컴파일 언어와는 달리 오류가 있는 직전 줄까지는 실행   
  * 한 줄 씩 해석하며 실행하기 때문에 일반적으로 컴파일 언어보다 느림  
---
### 3) 목적 파일 vs 실행 파일   
* `목적 파일` : 목적 코드로 이루어진 파일   
* 실행 파일 : 실행 코드로 이루어진 파일   
* `링킹 (Linking)` : 목적 코드 -> 실행 파일   
---
## 3-2. 명령어의 구조
### 1) 연산 코드와 오퍼랜드   
* 명령어 = 연산 코드 + 오퍼랜드   
  * `연산 코드(opreration code = 연산자)` : 명령어가 수행할 연산   
  * `오퍼랜드(operand = 피연산자)`  : 연산에 사용할 데이터   

> 위에서 본 캡쳐에서 `int = a = 10;` 이라는 코드가 실행 될 때의 메모리를 확인할 수 있다.
> 초록색으로 표시한 주소의 명령어가 dword ptr 와 [rbh+2ch], 0Ah 로 구성되어 있음을 확인할 수 있다.   
> 연산 코드 dword의 경우 앞서 Chapter 2. 에서 봤던 double word 를 의미하며 ptr은 포인터.
> 현재 코드에서 오퍼랜드가 [rbp+2Ch], 0Ah 두 개로 구성되어 있음을 알 수 있다. 
> rbp는 포인터를 저장하는 레지스터(스택 프레임에서 복귀 주소를 저장한다)
> 0A는 a 변수에 저장한 값 10과 일치한다.
> 이와 같은 명령어를 2-주소 명령어라고 한다.
> ![](https://velog.velcdn.com/images/cheeeedy/post/6503197a-c809-4322-8441-d42e3e79f576/image.png)   

* 연산코드의 종류
  * **데이터 전송**   
    * MOVE / STORE / LAD(FETCH) / PUSH / POP   
  * **산술/논리 연산**   
    * ADD / SUBTRACT / MULTIPLY / DIVIDE   
    * INCREMENT / DECREMENT   
    * AND / OR / NOT   
    * COMPARE (TRUE/FALSE 반환)   
  * **제어 흐름 변경**   
    * JUMP / CONDITIONAL JUMP / HALT / CALL / RETURN   
  * **입출력 제어**   
    * READ(INPUT) / WRITE(OUTPUT) / START IO / TEST IO   

---
### 2) 주소 지정 방식
* 보완 필요
---
### 3) 스택과 큐
#### (1) 스택
* Stack : Last In First Out (LIFO) 구조   
  * 후입선출   
  * PUSH :  스택에 새로운 데이터 저장 / POP : 스택 최상단 데이터 인출   
#### (2) 큐   
* Queue : First In First Out (FIFO) 구조   
  * 선입선출
