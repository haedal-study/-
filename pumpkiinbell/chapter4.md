# 4. CPU의 작동 원리

## 4.1 ALU와 제어장치

### ALU (Arithmetic Logic Unit)

![ALU](https://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/ALU_block.gif/440px-ALU_block.gif)

**ALU 가 받아들이는 정보**

- 피연산자: 레지스터를 통해 연산을 할 대상을 받는다.
- 제어 신호: 제어 장치로부터 수행할 연산을 알려주는 제어 신호를 받는다.

**ALU 가 내보내는 정보**

- 결과값: 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장된다.
  - CPU 의 메모리 접근 속도는 레지스터에 비해 느리기 때문에, ALU 가 연산할때마다 결과를 메모리에 저장하면 프로그램 실행 속도에 병목이 될 수 있다.
- 플래그: 연산 결과에 대한 추가적인 정보
  - 결과값에 대한 정보를 나타낸다. 부호, 0인지 여부, 캐리 여부 등이 있다.
  - 플래그 레지스터라는 레지스터에 저장된다.

### 제어 장치 (Control Unit)

![control-unit](https://www.elprocus.com/wp-content/uploads/control-unit-block-diagram.jpg)

**제어 장치가 받아들이는 정보**

- 클럭(Clock) 신호
  - Clock 은 컴퓨터의 모든 부품을 일괄적으로 움직일 수 있게 하는 시간 단위이다.
    - 가령, 클락의 주기에 맞춰 레지스터 간의 데이터 이동이나 ALU 연산 수행 등으 ㄹ하게 된다.
- 해석해야 할 명령어
  - 명령어 레지스터로부터 해석할 명령어를 받고 해석한 후, 제어 신호를 발생시킨다.
  - 이 제어 신호가 컴퓨터 부품들에 수행해야 할 내용을 알려준다.
- 플래그 값
  - 플래그 레지스터 속 플래그 값을 받는다.
- 시스템 버스, 그 중 제어 버스로 전달된 제어 신호를 받는다.
  - 제어 신호는 CPU 외부 장치도 발생시킬 수 있다.

**제어 장치가 내보내는 정보**

- CPU 외부에 전달하는 제어 신호
  - 즉, 제어 버스로 제어 신호를 내보낸다는 말과 같다.
  - 메모리, 입출력 장치에 전달하는 제어 신호가 있다.
    - 메모리에 저장된 값을 일걱나 새로운 값을 쓰고 싶다면 메모리로 제어 신호를 내보낸다.
    - 입출력 장치의 값을 읽거나 새로운 값을 쓰고 싶다면 입출력 장치로 제어 신호를 내보낸다.
- CPU 내부에 전달하는 제어 신호
  - ALU, 레지스터에 전달하는 제어 신호가 있다.
    - ALU 에는 수행할 연산을 지시하기 위해 내보낸다.
    - 레지스터에는 레지스터 간 데이터 이동, 명령어 해석을 위해 제어 신호를 내보낸다.

## 4.2 레지스터

_프로그램 속 명령어, 데이터는 실행 전 후로 반드시 레지스터에 저장된다._

_따라서 레지스터 저장 값만 잘 관찰해도 프로그램의 실행 흐름을 알 수 있다._

### 반드시 알아야 할 레지스터

**프로그램 카운터 (PC, Program Counter)**

메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장한다.

**명령어 레지스터 (IR, Instruction Register)**

해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다.

**메모리 주소 레지스터 (MAR, Memory Address Register)**

메모리의 주소를 저장하는 레지스터.
CPU 가 읽어 들이고자 하는 주소 값을 주소 버스로 내보낼 때 메모리 주소 레지스터를 거친다.

**메모리 버퍼 레지스터 (MBR, Memory Buffer Register)**

메모리와 주고 받을 값(데이터와 명령어)을 저장하는 레지스터.
즉, 메모리에 쓰고 싶거나 메모리로부터 전달 받은 값은 메모리 버퍼 레지스터를 거친다.

**범용 레지스터 (General Purpose Register)**

다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터. 데이터와 주소를 모두 저장할 수 있다.

**플래그 레지스터 (Flag Register)**

연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터

### 특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식

**스택 주소 지정 방식**

- 스택과 스택 포인터를 이용한 주소 지정 방식이다.

**스택 포인터**

- 스택 주소 지정 방식으로 으로 주소를 지정할 때 사용한다.

- 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터이다.

**스택 영역**

- 메모리 내부에 스택처럼 사용할 영역을 위해 암묵적으로 약속된 영역이다.

### 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식

**변위 주소 지정 방식 (displacement addressing mode)**

- 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다.
- 일반적인 명령어와 달리, 변위 주소 지정 방식을 사용하는 경우 Register 필드가 포함된다.

![DAM](https://static.studytonight.com/computer-architecture/images/displacement-addressing-mode.png)

오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 **상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식** 등으로 나뉜다.

- **상대 주소 지정 방식**: 오퍼 랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
- **베이스 레지스터 주소 지정 방식**: 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

### 상용화된 CPU 속 레지스터 및 주소 지정 방식

https://github.com/kangtegong/self-learning-cs/blob/main/registers/registers.md#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-arm-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0

## 4.3 명령어 사이클과 인터럽트

### 명령어 사이클

- 프로그램 속 명령어들은 일정한 주기가 반복되며 실행된다. 이 주기를 **명령어 사이클** 이라고 한다.
  명령어 사이클은 **인출 -> 실행** 을 반복하며 실행된다.
  - 인출 사이클: 메모리에 있는 명령어를 CPU 로 가지고 오는 단계
  - 실행 사이클: CPU 로 가져온 명령어를 실행하는 단계.
    제어 장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계.
  - 간접 사이클: 명령어를 실행하기 위해서 메모리 접근을 한번 더 해야 하는 단계.
    - 명령어를 인출하여 CPU 로 가져왔을 때, 곧바로 실행할 수 없는 경우가 있다.
    - 가령, 유효 주소가 담겨 있어 메모리 접근이 더 필요한 경우, 이를 위한 메모리 접근을 한번 더 해야 한다.

### 인터럽트

- CPU 가 수행 중인 작업을 방해하는 신호를 **인터럽트**라고 한다. 크게 **동기 / 비동기** 인터럽트가 있다.
- 동기 인터럽트 (예외)
  - CPU 에 의해 발생하는 인터럽트이다.
  - CPU 가 실행하는 프로그래밍 상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트.
  - 예외(Exception) 라 부르기도 한다.
- 비동기 인터럽트 (하드웨어 인터럽트)
  - 입출력장치에 의해 발생하는 알림과 같은 인터럽트이다.
  - 인터럽트 처리 순서
    1. 입출력장치가 CPU 에 **인터럽트 요청 신호**를 보낸다.
       - 인터럽트 요청 신호: CPU 에게 인터럽트를 해도 되는지 요청하는 신호
    2. CPU 는 실행 사이클이 끝난 후, 명령어 인출 전 인터럽트 여부를 확인한다.
    3. **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
       - 인터럽트 플래그: 인터럽트 요청를 수용할 것인지, 무시할 지를 결정하는 플래그이다.
       - 그러나, 정전, 하드웨어 고장으로 인한 인터럽트는 무시할 수 없다.
    4. 3이 가능하다면, CPU 는 지금까지의 작업을 백업한다.
    5. CPU 는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
       - 인터럽트 서비스 루틴(인터럽트 핸들러): 인터럽트를 처리하기 위한 프로그램.
         인터럽트가 발생했을 때, 해당 인터럽트를 어떻게 처리하고 작동해야 할 지에 대한 정보로 이루어진 프로그램
       - 인터럽트 벡터: 인터럽트 서비스 루틴을 식별하기 위한 정보.
         벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있다.
    6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개한다.

### 예외의 종류

동기 인터럽트(예외) 엔 크게 4가지의 예외가 있다.

- 폴트(fault): 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외.
  - ex) 명령어를 실행하기 위해 필요한 데이터가 메모리가 아닌 보조기억장치에 있는 경우
- 트랩(trap): 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
  - ex) 디버깅
- 중단(abort): CPU가 실행 중인 프로그램을 중단시킬 수 밖에 없는 심각한 오류를 만난 경우
- 소프트웨어 인터럽트(software interrupt): 시스템 호출이 발생했을 때 나타남
