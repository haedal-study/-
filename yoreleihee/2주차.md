# 3. 명령어
## 소스 코드와 명령어
프로그래머는 고급 언어로 소스 코드를 작성한다. 이 고급 언어는 사람이 이해하기 쉽게 만들어졌지만, 컴퓨터는 이해하지 못한다. 따라서 프로그램을 실행하려면 고급 언어를 컴퓨터가 이해할 수 있는 저급 언어로 변환해야 한다. 이 변환된 저급 언어는 컴퓨터가 직접 실행할 수 있는 명령어로 구성된다.

### 고급 언어와 저급 언어
저급 언어에는 크게 두 가지 형태가 있다. 첫 번째는 0과 1로 표현된 기계어다. 두 번째는 기계어를 사람이 이해할 수 있도록 번역된 어셈블리어다. 어셈블리어는 하드웨어와 밀접하게 연관된 프로그램을 개발하는 분야에서 많이 이용되기도 한다.

고급언어는 대체로 컴파일 언어와 인터프리터 언어로 나눌 수 있다. 컴파일 언어에는 C#, C++ 등이 있으며, 소스 코드가 컴파일러에 의해 컴파일되어 목적 코드가 생성된다. 이 과정에서 컴파일러는 소스 코드를 처음부터 끝까지 검사하여 한 번에 변환한다. 반면, 인터프리터 언어는 한 줄씩 바이트 코드로 변환하며 소스 코드 전체가 저급 언어로 변환되기까지 기다릴 필요가 없다. 대표적인 인터프리터 언어로는 JavaScript, Phtyon등이 있다. 언어 분류에는 항상 명확한 경계가 존재하는 것은 아니나, 대표적인 분류 방법이다.

### C언어 컴파일 과정
전처리기 -> 컴파일러 -> 어셈블러 -> 링킹의 단계를 거친다. 
#### 전처리 과정(Preprocessing)
전처리 지시자를 해석하고 처리하게 된다. 이 과정에서 다양한 라이브러리를 가져오거나 매크로를 변환하거나 특정 영역을 컴파일할지를 결정하게 된다.
> - 라이브러리 불러오기
> #include
> - 매크로 변환 
> #define
> - 컴파일할 영역 명시 
> #if, #ifdef

#### 컴파일 과정(compiling)
컴파일러는 전처리가 완료된 소스 코드를 저급 언어(어셈블리 언어)로 변환한다. 이 과정에서 문법의 정확성을 검증하며 문제가 있을 경우, 에러 메시지를 통해 피드백을 제공한다. 또한 이 단계에서는 최적화가 이루어지는데 중복되는 연산을 제거하거나 메모리 접근을 최소화하는 등의 최적화를 수행한다. 

>[이에 따라 예기치 못하는 컴파일 이슈가 발행할 수 있는데 먼저 컴파일러가 코드를 생략하게 되는 과정을 살펴보자.]

#### 어셈블 과정(assembling)
컴파일러가 생성한 저급 언어를 기계어로 변환한다. 이 과정에서 목적 코드를 포함하는 목적 파일이 생성된다.

### 링킹
이렇게 컴파일된 목적 파일도 아직 컴퓨터가 실행시킬 수 있는 완전한 프로그램이 아니다. 이 목적파일을 실행할 수 있는 프로그램으로 만들기 위해서는 링킹(linking)이라는 과정이 필요하다. 링킹은 목적파일과 라이브러리를 결합해 하나의 실행파일로 만드는 과정을 말한다.

### 명령어의 구조
명령어는 기본적으로 연산의 대상을 나타내는 오퍼랜드와 명령어의 실질적인 작업을 나타내는 연산 코드로 이루어져 있다.
![스크린샷 2023-08-06 오전 1.38.09](https://i.imgur.com/B3o6Bxl.png)


#### 오퍼랜드
오퍼랜드는 연산에 사용되리 데이터 혹은 연산에 사용될 데이터가 저장된 주소를 나타낸다. 주로 주소를 나타냄으로 주소 필드라고 불리기도 한다. 모든 명령어가 오퍼랜드를 가지는 것은 아니며, 오퍼랜드가 없거나 하나 이상인 경우도 있다.

![스크린샷 2023-08-06 오전 1.41.33](https://i.imgur.com/OFVv7I3.png)
빨간 글씨가 연산 코드, 검은 글씨가 오퍼랜드다.

#### 연산 코드
연산 코드는 수행할 특정 연산을 나타내는 코드다. CPU마다 연산 코드의 종류와 형태가 다를 수 있으나, 대체로 다음과 같은 공통적인 기능으로 분류된다.
- 데이터 전송: 기억장치 간에 데이터를 이동하는 연산을 수행한다.
- 산술/논리 연산: 사칙연산, 논리 연산 등의 계산을 수행한다.
- 제어 흐름 변경: 명령어의 실행 순서나 흐름을 변경한다.
- 입출력 제어: CPU와 외부 장치 간의 데이터 입출력을 제어한다.

### 주소 지정 방식
앞서 오퍼랜드는 주로 데이터가 있는 주소를 나타내는 경우가 많기 때문에 주소 필드라고도 불린다고 했는데 왜 데이터 자체를 저장하기보다 주소가 저장되는 경우가 많을까? 그 이유는 오퍼랜드는 데이터를 담을 수 있는 크기가 한정되어 있기 때문이다. 예를 들어 1-주소 명령어는 연산 코드 메모리 공간을 제외한 오퍼랜드에 가장 많은 데이터를 할당할 수 있지만 2 주소, 3 주소로 갈수록 각각의 오퍼랜드가 할당할 수 있는 메모리 공간은 적어진다. 

가령 명령어의 크기가 16비트라면 연산 코드는 4비트라고 해보자. 2-주소 명령어에서는 16비트에서 4비트를 뺀 12비트에 오퍼랜드를 할당할 수 있다. 그리고 각각의 오퍼랜드는 다시 둘로 나누어져 6비트씩 할당받는다.
![스크린샷 2023-08-06 오후 10.21.11](https://i.imgur.com/OtLmfWG.png)
2-주소 명령어의 예시

![스크린샷 2023-08-06 오후 10.21.31](https://i.imgur.com/Y68AxM7.png)
3-주소 명령어의 예시

한 주소에 16비트를 저장할 수 있는 메모리가 있다고 가정했을 때, 주소 지정 방식을 사용하면 아래 이미지와 같이 더 많은 데이터를 표현할 수 있다.
![스크린샷 2023-08-06 오후 10.22.08](https://i.imgur.com/xNYzjqB.png)

연산에 필요한 데이터가 저장되는 위치를 유효 주소라고 한다. 즉, 주소 지정 방식은 유효 주소를 찾는 방법이라고 할 수 있다. 주소 지정 방식에는 여러 종류가 있는데 그중에서 대표적인 5가지에 대해 알아보자.

#### 즉시 주소 지정 방식
연산에 필요한 데이터를 오퍼랜드에 바로 저장하는 것으로 메모리의 크기가 제한될 수 있지만 데이터에 접근이 빠르다.

#### 직접 주소 지정 방식
오퍼랜드 필드에 유효 주소를 저장하는 방식이다. 표현할 수 있는 데이터 크기는 커졌지만, 여전히 연산 코드를 제외한 필드를 사용할 수 있으므로 주소 표현에 제한이 있다.

#### 간접 주소 지정 방식
오퍼랜드 필드에 유효 주소의 주소를 명시하는 방법이다. 사용할 수 있는 메모리는 커졌지만 데이터에 접근 속도가 느리다.

#### 레지스터 주소 지정 방식
연산에 사용할 데이터가 저장된 레지스터를 명시하는 방법이다. CPU는 메모리에 접근하는 것보다 CPU 내의 레지스터에 접근하는 것이 빠르기 때문에 직접 주소 방식보다 빠르게 데이터에 접근할 수 있다. 직접 주소 방식과 비슷하게 주소 표현에 제한이 있다.

#### 레지스터 간접 주소 지정 방식
간접 주소 지정 방식과 비슷하게 메모리에 실제 값을 저장하고 그 유효 주소를 저장한 레지스터를 오퍼랜드에 저장하는 방법이다. CPU는 레지스터에 접근하는 것이 메모리에 접근하는 것보다 빠르므로 간접 주소 지정 방식보다 빠르다.