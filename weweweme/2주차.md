# **Chapter 3: 명령어**

## **3-1. 소스 코드와 명령어**

- 모든 소스 코드는 컴퓨터 내부에서 명령어로 변환된다

## 고급 언어와 저급 언어

### 고급 언어(high-level programming language)

- 대부분의 프로그래밍 언어를 뜻한다

### 저급 언어(low-level programming language)

- 컴퓨터가 이해하고 실행할 수 있는 명령어로 구성되어 있으며, 기계어와 어셈블리어로 분류된다
  - 기계어(machine code) : 0과 1의 명령어 비트로 이루어진 언어
  - 어셈블리어(assembly language) : 명령어를 읽기 편한 형태로 번역한 언어

 ![기계어와 어셈블리어](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCbBb9%2FbtqUvDDBxH1%2FieF1PJ4JVqFNGtKMqLYpDk%2Fimg.png)"

### 저급 언어를 알아야 하는 이유

- 프로그램의 실행 과정을 근본적인 단계에서부터 추적/관찰이 가능해진다

## 컴파일 언어와 인터프리터 언어

- 언어가 변환되는 두 가지 방식이 존재하는데 각각 컴파일과 인터프리트 방식

### 컴파일 언어 : 컴파일 방식으로 동작하는 언어

- 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
- 변환을 수행하는 도구를 컴파일러라 한다
- 코드가 실행 가능한지, 오류는 없는지 검사하는 역할을 하며 이상이 하나라도 발견된다면 컴파일에 실패한다
- 변환된 코드는 세컨더리 메모리에 저장된다
- 코드가 최적화 가능할 경우, 컴파일러는 추가적인 최적화를 수행한다
- 컴파일이 성공적으로 수행되면 저급 언어로 변환되게 되는데 이렇게 변환된 코드를 목적 코드(object code)라 부른다

![고급언어, 컴파일러, 저급언어](https://velog.velcdn.com/images/hunmok1027/post/20369d91-17cb-48de-9081-841486dab79d/image.png)

### 인터프리트 언어 : 인터프리트 방식으로 동작하는 언어

- 소스 코드를 한 줄씩 차례로 실행하며 저급 언어로 변환하며, 이 변환을 수행하는 도구를 인터프리터라 부른다
- 소스 코드를 한 줄씩 실행하기 때문에 N번째 줄에 오류가 있더라도 N+1번 까지는 동작을 수행한다
- 변환된 코드는 저장되지 않고, 프로세스에서 사용된다
- 컴파일의 결과물인 목적 코드는 저급 언어인 반면, 인터 프리터는 한 줄씩 해석하며 실행하기 때문에 상대적으로 느리다

### 정리

- 현대의 많은 프로그래밍 언어는 반드시 둘 중 하나의 방식으로 동작하지 않는다
- 고급 언어와 저급 언어로 변환되는 대표적인 방법에는 컴파일 방식과 인터프리트 방식이 있다 정도로 유연하게 받아들이는 것이 중요하다

## 목적 파일과 실행 파일

### 목적 파일

- 목적 코드로 이루어진 파일을 뜻한다

### 실행 파일

- 실행 코드로 이루어진 파일을 뜻하며, .exe 파일이 대표적이다

### 링킹

- 여러 목적 코드와 라이브러리 파일들을 하나의 실행 파일로 결합하는 과정으로, 정적 링킹(static linking)과 동적 링킹(dynamic linking)으로 나뉜다

#### 정적 링킹

- 컴파일 시간에 모든 라이브러리의 코드가 메인 프로그램 코드와 결합되어 하나의 실행 파일을 생성한다
- 실행 파일이 더 크지만, 외부 의존성이 없어 이식성이 높다
- 외부 라이브러리의 업데이트가 있을 때마다 메인 프로그램을 다시 컴파일해야 한다

> ex. C언어에서 'printf' 함수를 사용할 때, 이 함수는 표준 C라이브러리에 정의되어 있다. 정적 링킹을 사용할 경우, 프로그램을 컴파일 할 때 'printf' 함수의 실행 코드가 최종 실행 파일에 포함되어 있다

#### 동적 링킹

- 실행 시간에 필요한 라이브러리 코드가 메인 프로그램에 로드된다
- 실행 파일 크기가 상대적으로 적다
- 실행 시간에 필요한 라이브러리가 시스템에 존재해야 하며, 해당 라이브러리의 버전이 호환되어야 한다
- 외부 라이브러리의 업데이트가 있을 때 메인 프로그램을 다시 컴파일 할 필요가 없다

> ex. Windows에서 DLL(Dynamic Link Libraries)을 사용하는 경우. 프로그램 실행 시 DLL 파일이 로드되어 필요한 기능을 제공한다. 프로그램은 해당 DLL의 함수나 변수를 참조하기만 하며, 실제 구현은 DLL 파일 내에 있다

## **3-2. 명령어의 구조**

## 연산 코드와 오퍼랜드

- 명령어는 '어떤 동작을 무엇을 대상으로 수행하라'의 구조를 지닌다
- '어떤 동작을 수행하라' 라는 것은 연산 코드로 나타내며, '무엇을 대상으로' 라는 것은 오퍼랜드로 나타낸다
- 이때 연산 코드를 연산자, 오퍼랜드를 피연산자라 표현하기도 합니다

![연산 코드와 오퍼랜드](https://velog.velcdn.com/images/thdgusrbek/post/4c71672a-30a5-4420-9a31-64ff0e1d9669/image.png)

![어셈블리 코드](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99F2153A5C10981023)
왼쪽 push, mov, sub 등은 연산 코드를 뜻하며 ebp, esp 등은 오퍼랜드를 뜻한다

### 오퍼랜드(operand)
- 데이터 자체보다 데이터가 저장된 위치가 기록되어 있는데 메모리 주소 또는 레지스터가 적혀있다
- 주소 필드라는 이름으로도 불린다
- 오퍼랜드는 0-3개 까지 존재할 수 있으며, 각각 0-3 주소 명령어라고 한다

![오퍼랜드](https://velog.velcdn.com/images/thdgusrbek/post/93c23bf3-825c-414f-bed1-ad875e8c2ffe/image.png)

### 연산 코드(operation code)
- 종류는 매우 많지만 크게 네 가지로 나뉜다

> 아래와 같이, 연산을 알파벳 기호로 표기한 것을 [니모닉(mnemonic)](https://en.wikipedia.org/wiki/Mnemonic)라고 하며, 니모닉란 인간이 기억하기 쉬운 형태로 이름을 나타내는 기호를 뜻합니다

#### 데이터 전송
- MOVE : 데이터를 옮겨라
- STORE : 메모리에 저장하라
- LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
- PUSH : 스택에 데이터를 저장하라
- POP : 스택의 최상단 데이터를 가져와라

#### 산술 / 논리 연산
- ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
- INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
- AND / OR / NOT : AND / OR / NOT 연산을 수행하라
- COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라

#### 제어 흐름 변경
- JUMP : 특정 주소로 실행 순서를 옮겨라
- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- HALT : 프로그램의 실행을 멈춰라
- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
- RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라

#### 입출력 제어
- READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
- WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
- START IO : 입출력 장치를 시작하라
- TEST IO : 입출력 장치의 상태를 확인하라

## 주소 지정 방식(addressing mode)
- 오퍼랜드에는 다양한 방식으로, 데이터에 접근할 수 있는 방법을 제공한다
- 다양한 방식을 사용하는 이유는, 명령어를 담는 바이트 중, 오퍼랜드를 위해 할당된 바이트는 한정되어 있기 때문
- 따라서 오퍼랜드에는 사용할 데이터 자체, 데이터가 저장된 메모리 주소 혹은 레지스터가 담긴다
- 연산의 대상이 되는 데이터가 저장된 위치를 **유효 주소**(effective address)라 부른다
- 현재 CPU는 다양한 주소 지정 방식을 사용하며 소개된 방식 외에도 다양한 방식이 존재한다

### 즉시 주소 지정 방식(immediate addressing mode)
- 가장 간단한 형태의 오퍼랜드로, 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
- 표현할 수 있는 데이터의 크기가 작아지지만, 연산에 사용할 데이터를 바로 사용 가능해서 속도가 빠르다

![즉시 주소 지정 방식](https://velog.velcdn.com/images/thdgusrbek/post/83e7d99a-0310-467e-8e56-511f09fd1b9b/image.png)

예시

> MOV AX, #5

> AX 레지스터에 5를 저장

### 직접 주소 지정 방식(direct addressing mode)
- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
- 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 이기때문에, 이 또한 표현할 수 있는 유효 주소에 제한이 있다

![직접 주소 지정 방식](https://velog.velcdn.com/images/thdgusrbek/post/51ab02d7-df2a-4884-b511-b7384c4c557e/image.png)

예시

> MOV AX, [1000h]

> 메모리 주소 1000h에 저장된 값을 AX 레지스터에 복사

### 간접 주소 지정 방식(indirect addressing mode)

유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식입니다

표현할 수 있는 유효 주소의 범위가 더 넓어지며, 두 번의 메모리 접근이 필요하기 때문에 앞선 방식 보다는 느립니다

![간접 주소 지정 방식](https://velog.velcdn.com/images/thdgusrbek/post/c6c221d3-413e-400b-aff6-76b0ccbb843e/image.png)

예시

> MOV BX, 1000h
> MOV AX, [BX]
> BX에 저장된 주소, 즉 1000h에 위치한 메모리 값을 AX에 저장

### 레지스터 주소 지정 방식(register addressing mode)
- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법
- CPU가 접근할 수 있는 메모리중 가장 빠른 메모리는 레지스터이며, 따라서 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다
- 하지만 레지스터는 고정된 비트 수로 구성되어 있기 때문에 그 이상의 데이터를 직접 저장할 수 없다는 단점이 있다

![레지스터 주소 지정 방식](https://velog.velcdn.com/images/thdgusrbek/post/a39d01ad-ebb8-4a56-8357-a3dae1a781fc/image.png)

예시

> MOV AX, BX

> BX 레지스터의 값을 AX 레지스터로 복사

### 레지스터 간접 주소 지정 방식(register indirect addressing mode)
- 연산에 사용할 데이터를 메모리에 저장하고, 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식이다
- 메모리에 저장된 유효 주소를 참조하여 필요한 데이터를 얻는 방식이다
- 간접 주소 지정 방식과 유사하게 동작한다
- 하지만 CPU가 레지스터에 직접 접근할 수 있기 때문에, 간접 주소 지정 방식보다 더 빠른 성능을 제공한다

![레지스터 간접 주소 지정 방식](https://velog.velcdn.com/images/thdgusrbek/post/6676cdc2-2f8a-4c1a-b4d6-a0383ce05f14/image.png)

예시

> MOV BX, [1000h]
> MOV AX, [BX]

> BX 레지스터에 저장된 메모리 주소(1000h에서 가져온 값)에서 데이터를 읽어 AX에 저장

### 상대 주소 지정 방식(relative addressing mode)
- 오퍼랜드 필드에 프로그램 카운터(PC; program counter)와의 상대적인 거리 또는 오프셋(offset)을 지정하는 방식이며, 이 오프셋은 PC에 더해져서 실제 유효 주소를 얻는다
- 이 방식은 주로 분기나 점프 명령에서 사용됩니다

![상대 주소 지정 방식](https://media.geeksforgeeks.org/wp-content/uploads/20200830223820/PCRelativeMode.jpg)

예시

> JMP +4

> 현재 명령어 위치에서 4바이트 뒤로 점프

### 인덱스 주소 지정 방식(indexed addressing mode)
- 특정 레지스터(인덱스 레지스터)의 값과 오퍼랜드 필드의 값을 더하여 유효 주소를 계산한다
- 주로 배열이나 테이블에 대한 접근에 사용된다

![인덱스 주소 지정 방식](https://cstaleem.com/wp-content/uploads/2020/07/Indexed-Addressing-Mode.png)

예시

> MOV AX, [BX+4]

> BX 레지스터 값에 4를 더한 주소의 메모리 값으로 AX 레지스터를 설정

### 자동 인덱싱 방식(auto-indexing mode)
- 명령어 실행 후에 자동으로 인덱스 레지스터의 값이 증가하거나 감소하는 방식이다
- 이 방식은 연속된 메모리 위치에 접근할 때 유용하다

![자동 인덱싱 방식](https://cstaleem.com/wp-content/uploads/2020/07/Auto-Increment-Addressing-Mode-1024x562.png)

예시

> LD R1, [R2+]

> R2 레지스터에 저장된 주소의 메모리 값을 R1 레지스터에 로드하고, R2 값을 1 증가시킴