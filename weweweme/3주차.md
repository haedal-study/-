# **Chapter 4: CPU의 작동 원리**

---

## **4-1. ALU와 제어 장치**

---

## 4-1-1. ALU(Arithmetic Logic Unit)

![ALU의 동작](https://velog.velcdn.com/images/zenon8485/post/7f1bc7bb-40ac-42f7-a3fb-0eebc4ec9d76/image.png)

- ALU : CPU 내부에 존재하며 산술 및 논리 연산을 수행하는 하드웨어
- ALU가 입력받는 데이터는 다음과 같다.
  - 레지스터를 통해 전달받는 피연산자(어떤 데이터를 연산할 것인지)
  - 제어장치가 알려주는 제어 신호(어떤 연산을 진행할 것인지)
- 내보내는 데이터는 다음과 같다.
  - 계산 결과
  - 플래그 레지스터
- CPU는 연산의 결과를 다양한 방식으로 활용하여 프로그램의 실행을 제어하고 데이터 처리를 수행한다.
- 데이터 처리를 위해 주로 레지스터에 저장된 값을 사용하는데, CPU가 사용 가능한 메모리 중 레지스터가 가장 빠르다.
- 이와 같은 이유로, ALU는 연산의 결과를 레지스터에 저장한다.

### 플래그(Flag)

#### 정의

- 연산 결과에 대한 추가 적인 상태 정보를 플래그라 한다.

#### ALU가 내보내는 대표적인 플래그

- 부호 플래그
  - 연산한 결과의 부호를 나타낸다.
  - 부호 플래그가 1일 경우 계산 결과는 음수, 0일 경우 계산 결과는 양수를 의미한다.
- 제로 플래그
  - 연산 결과가 0인지 여부를 나타낸다.
  - 제로 플래그가 1일 경우 연산 결과는 0, 0일 경우 연산 결과는 0이 아님을 의미한다.
- 캐리 플래그
  - 연산 결과 올림수나 빌림수가 발생했는지를 나타낸다.
  - 캐리 플래그가 1일 경우 올림수나 빌림수가 발생했음을 의미하고, 0일 경우 발생하지 않았음을 의미한다.
- 오버플로우 플래그
  - 오버플로우가 발생했는지를 나타낸다.
  - 오버플로우 플래그가 1일 경우 오버플로우가 발생했음을 의미하고, 0일 경우 발생하지 않았음을 의미한다.
- 인터럽트 플래그
  - 인터럽트가 가능한지를 나타낸다.
  - 인터럽트 플래그가 1일 경우 인터럽트가 가능함을 의미하고, 0일 경우 인터럽트가 불가능함을 의미한다.
- 슈퍼바이저 플래그
  - 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다.
  - 슈퍼바이저 플래그가 1일 경우 커널 모드로 실행 중임을 의미하고, 0일 경우 사용자 모드로 실행 중임을 의미한다.

---

## 4-1-2. 제어장치

![제어장치](https://cdn1.byjus.com/wp-content/uploads/2022/05/introduction-to-control-unit-1.png)

- 제어장치 : 제어 신호를 내보내고 명령어를 해석하는 부품

> 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호

### 제어장치가 받아들이는 정보

#### 클럭 신호

- 클럭(clock) : 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위
- 컴퓨터의 모든 부품은 클럭 신호에 맞춰 동작한다.
- 이 때 주의해야 할 점은, 모든 부품이 한 클럭마다 작동한다는 의미는 아니다.
- 예시 : 메트로놈과 음악 연주
  - 메트로놈은 일정한 간격으로 소리를 내며, 연주자들은 이 메트로놈의 리듬에 맞춰 음악을 연주한다.
  - 연주 곡에 따라, 연주자는 어떤 음은 짧게, 어떤 음은 길게 연주할 수 있다.
    - 어떤 음은 메트로놈의 한번 탁탁 사이에 연주될 수 있고, 어떤 음은 메트로놈의 여러 번 탁탁 소리에 맞춰 연주될 수 있다.

![클럭 예시](https://velog.velcdn.com/images/zenon8485/post/e9a38e74-dd4e-4e4c-9edb-c5080fd7e7b6/image.png)

#### 해석해야할 명령어

- CPU가 해석해야 할 명령어는 명령어 레지스터라는 메모리에 저장된다.
- 제어장치는 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한다.
- 이후 제어 신호를 발생시켜 컴퓨터 부품들에게 수행해야 할 내용을 알려준다.

#### 플래그 레지스터 속 플래그 값

- 제어장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다.

#### 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호

- 제어 신호에는 CPU 외부에 전달하는 제어 신호와 CPU 내부에 전달하는 제어 신호가 있다.
- 외부
  - 메모리에 전달하는 제어 신호와 입출력 장치에 전달하는 전달 신호가 있다.
  - 메모리(입출력 장치)에 저장된 값을 읽거나 메모리(입출력 장치)에 새로운 값을 쓰고 싶다면 메모리로 신호를 보낸다.
- 내부
  - CPU 내부에 전달하는 신호는 ALU 와 레지스터가 대상이 된다.
  - ALU에게는 수행할 연산을 지시하기 위해 신호를 보낸다.
  - 레지스터는 레지스터 간에 데이터를 이동시키거나 저장된 명령어를 해석하기 위해 신호를 보낸다.

## **4-2. 레지스터**

- 프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장된다.
- 이 원리로 레지스터에 저장된 값을 관찰하면 프로그램 실행 중 CPU 내에서 무슨 일이 벌어지는지 알 수 있다.

### 반드시 알아야 하는 필수적인 레지스터

#### 프로그램 카운터(PC; Program Counter)

- 메모리에서 가져올 명령어의 주소. 즉, 메모리에서 읽어 들일 명령어의 주소를 저장한다.
- 명령어 포인터(IP; Instruction Pointer)라고 부르는 CPU도 있다.
- 자주 갱신되는 레지스터로, 명령어 실행이 종료될 때마다 다음 명령어의 주소로 자동 업데이트 된다.
- 일반적으로는 PC는 꾸준히 증가하여 프로그램을 차례대로 실행한다.
- 하지만 분기, 점프, 호출 등의 명령어가 실행될 때 해당 명령어가 지시하는 주소로 변경될 수 있다.

#### 명령어 레지스터(IR; Instruction Register)

- 해석할 명령어. 즉, 방금 메모리에서 읽어들인 명령어를 저장하는 레지스터
- 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.

#### 메모리 주소 레지스터(MAR; Memory Address Register)

- 메모리의 주소를 저장하는 레지스터
- CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.

#### 메모리 버퍼 레지스터(MBR; Memory Buffer Register)

- 메모리와 주고 받을 값을 저장하는 레지스터
- 메모리에 쓰고 싶은 값이나 전달받은 값은 메모리 버퍼 레지스터를 거친다.
- CPU가 데이터 버스로 주고 받은 값은 메모리 버퍼 레지스터를 거치는 것이다.

#### 플래그 레지스터(FR; Flag Register)

- ALU의 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터

#### 범용 레지스터(GPR; General Purpose Register)

- 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
- 데이터와 주소를 모두 저장할 수 있다.
- 일반적으로 CPU 내에는 여러 개의 범용 레지스터들이 있고, 현대 대다수 CPU는 모두 범용 레지스터를 가지고 있다.
- 연산 중 임시로 값을 저장하거나 중간 결과를 보관하는 용도로 사용된다.

#### 스택 포인터(Stack Pointer)

- 스택의 꼭대기를 가리키는 레지스터
- 즉, 마지막으로 저장한 값의 위치를 저장하는 레지스터이다.
- 함수 호출이나 인터럽트 발생 시, 반환 주소나 중요한 레지스터 값을 저장하기 위해 사용한다.
- 함수의 반환이나 인터럽트 처리가 끝나면, 스택 포인터를 통해 이전 상태로 복구가 가능하다.

#### 베이스 레지스터(Base Register)

- 메모리 접근을 위한 기준 주소값을 저장하는 레지스터
  - 기준 주소값이란 메모리 내 특정 위치를 가리키는 시작점 혹은 기준점의 주소를 의미한다.
- 일정 범위의 메모리에 접근할 때, 베이스 레지스터에 저장된 주소와 다른 레지스터의 오프셋 값을 더하여 실제 메모리 주소를 계산한다.
- 이로서 프로그램의 주소 공간과 실제 메모리의 주소 공간을 분리하여, 보안과 메모리 관리의 효율성을 높인다.

### 레지스터를 이용한 주소 지정 방식

#### 스택 주소 지정 방식(Stack Addressing Mode)

- 스택과 스택 포인터를 이용한 주소 지정 방식
- 스택 포인터는 스택의 꼭대기를 항상 가리키며, 스택에 데이터를 푸시하거나 팝하는 동작을 수행할 때 이 주소 지정 방식이 사용된다.
- 이 방식은 함수 호출, 지역 변수의 저장, 인자 전달 등에 주로 사용된다.

1. 변위 주소 지정 방식(Displacement Addressing Mode)

- 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
- 이 방식은 배열이나 구조체 등의 타입에 대한 접근에서 주로 사용된다.

**상대 주소 지정 방식(Relative Addressing Mode)**

1. 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
1. 주로 조건 분기나 무조건 분기 명령에서9 사용되며, 현재 실행 중인 명령어의 위치를 기준으로 특정 오프셋만큼 떨어진 위치의 명령어로 점프한다.
1. 프로그래밍 언어의 if문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 사용할 때 사용한다.

**베이스 레지스터 주소 지정 방식(Base-Register Addressing Mode)**

- 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
- 주로 세그먼테이션 메모리 관리 방식에서 사용되며, 세그먼트의 시작 주소(베이스 레지스터 값)에 특정 오프셋(오퍼랜드 값)을 더해 실제 메모리 위치를 지정한다.
- 이 방식은 다양한 프로그램이나 태스크가 동시에 메모리에 존재할 때, 각각의 메모리 공간을 독립적으로 관리하기 위해 사용된다.

> 세그먼테이션 메모리 관리 방식이란, 주소 공간을 여러 개의 논리적 단위인 세그먼트(Segment)로 분리하여 관리하는 방식으로서 메모리를 더 효과적으로 사용하고, 보호 기능을 향상시키기 위해 사용하는 기법이다.

> 세그먼테이션 메모리 관리 방식에 대한 추가적인 설명은 다음의 [링크](https://en.wikipedia.org/wiki/Memory_segmentation)를 참고한다.

## **명령어 사이클과 인터럽트**

- CPU가 하나의 명령어를 처리하는 과정에는 정해진 흐름이 있고, 그 흐름을 반복하며 명령어를 처리한다.
- 이렇게 하나의 명령어를 처리하는 정형화된 흐름을 **명령어 사이클**이라 한다.
- 이 때, 이 정해진 흐름이 끊어지는 상황이 발생할 수 있는데 이를 **인터럽트**라고 한다.

## 명령어 사이클(Instruction Cycle)

### 과정

![명령어 사이클](https://binaryterms.com/wp-content/uploads/2021/03/Basic-Instruction-Cycle.jpg)

- 명령어를 메모리에서 CPU로 가져오는 **인출 단계(Fetch Stage)**
- 제어장치가 명령어 레지스터에 저장된 명령어를 해석하는 단계 **해석 단계(Decode Stage)**
- CPU로 가져온 명령어를 실행하는 단계인 **실행 단계(Execution Stage)**

#### 인출 사이클(Fetch Stage)
- 메모리에서 명령어를 가져오는 과정은 다음과 같다.
1. 다음 실행할 명령어를 프로그램 카운터에서 가져와 메모리 주소 레지스터에 저장한다.
2. 제어장치가 메모리에 읽기 요청에 관한 제어 신호를 보낸다. 이때 읽어들일 주소는 주소 버스를 통해 함께 전달된다.
3. 데이터 버스를 통해 메모리로부터 명령어가 전달되며, 이는 메모리 버퍼 레지스터에 저장된다.
4. 메모리 버퍼 레지스터에 저장된 명령어를 명령어 레지스터로 복사한다.
5. 프로그램 카운터에 저장된 값이 증가한다. 즉, 다음 명령어를  가리키게 된다.

#### 해석 단계(Decode Stage)
- 레지스터에 저장된 명령어를 해석하여 유효 주소를 도출한다.
  - 레지스터에 오퍼랜드가 없고 메모리에 있는 경우 메모리로부터 오퍼랜드를 가져와 알맞은 레지스터로 전송한다.
- 메모리로부터 데이터를 읽어 들이는 과정은 인출 사이클과 비슷하다.
  - 하지만 메모리 버퍼 레지스터에 저장된 데이터를 명령어 레지스터가 아닌 범용 레지스터로 옮긴다는 점과 프로그램 카운터의 값이 증가되지 않는다는 차이점이 있다.

#### 실행 단계(Execution Stage)
- 제어장치가 해석된 정보를 ALU에 전달해 산술 혹은 논리 연산을 하도록 지시한다.
- 결과값이 있다면 메인 메모리에 저장되거나 출력 장치로 전송될 수 있다.
- ALU의 피드백에 따라 프로그램 카운터의 값을 바꿔 다른 주소에서 명령어를 가져오도록 할 수 있다.
  - 이 동작이 위에서 나온 제어 신호를 발생시키는 일이다.
  - JUMP와 같은 분기문을 실행하는 경우가 있다.

---

## 인터럽트(Interrupt)

- CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있는데, 이렇게 CPU의 작업을 방해하는 신호를 의미한다.
  - 예로서 회사에서 일을 하는 도중, 상사에게 '더 급한 일이니 이것부터 처리해줘'라는 요청을 받는 경우로 생각한다.

### 인터럽트 시스템의 동작 방식

### 종류

![인터럽트의 종류](https://velog.velcdn.com/images/zenon8485/post/4fa1d033-fdbf-4372-be89-d3a447ed524a/image.png)

### 동기 인터럽트(Synchronous Interrupt), 예외

- CPU에 의해 발생하는 인터럽트
- CPU가 명령어들을 수행하다가 예상치 못한 상황을 마주쳤을 때 발생한다.

> 예시
> 프로그래밍상의 오류와 같은 예외 적인 상황에 마주쳤을 때 발생하는 인터럽트이다.

- 동기 인터럽트는 **예외**(Exception)라고도 부른다.
- 폴트와 트랩
  - 폴트 : 예외가 발생한 명령어 부터 처리한다.
  - 트랩 : 예외가 발생한 다음 명령어부터 처리한다.

#### 폴드(Fault)

- 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외

> 예시
> - CPU가 명령어를 실행하려하는데, 필요한 데이터가 메모리가 아닌 보조기억장치에 있는 경우, 폴트를 발생시키고 데이터를 메모리에 저장한다.
> - CPU는 다시 실행을 재개하고 폴트가 발생한 그 명령어부터 실행한다.

#### 트랩(Trap)

- 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부텅 실행을 재개하는 예외
- 주로 디버깅할 때 사용

> 예시
> - 특정 코드가 실행되는 순간 프로그램의 실행을 멈추게 한다.
> - 디버깅이 끝나면 프로그램은 다음 명령어부터 실행을 이어나간다.

#### 중단(Abort)

- CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외

#### 소프트웨어 인터럽트(Software Interrupt)

- 시스템 호출이 발생했을 때 나타난다.

### 비동기 인터럽트(Asynchronous Interrupt), 하드웨어 인터럽트

- 주로 입출력장치에 의해 발생하는 인터럽트

> 예시
> - CPU가 프린터와 같은 입출력장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력장치가 CPU에게 완료 알림을 보낸다.
> - 키보드, 마우스와 같은 입출력장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에게 알림을 보낸다.

- 하드웨어 인터럽트는 알림과 같은 인터럽트
- CPU의 동작 속도는 다른 부품들에 비해 엄청나게 빠르기 때문에, 주기적으로 작업 완료를 검사하는 풀링 방식은 비효율적이다.
- 하드웨어 인터럽트를 이용하면, 프린트로부터 완료 알림을 받기 전까지 자신의 작업을 처리할 수 있다.

#### 하드웨어 인터럽트의 처리 순서

![프로그램의 실행 순서](https://velog.velcdn.com/images/zenon8485/post/80531525-cf24-431e-91b4-a47b88f91f86/image.png)

1. 입출력장치는 CPU에게 **인터럽트 요청 신호**를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는 여부를 확인한다. 이를 **서비스(Service)**한다고 표현한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 **인터럽트 핸들러**를 이용하여 **인터럽트 벡터**를 참조, **인터럽트 서비스 루틴**을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 백업해 둔 작업을 복구하여 실행을 재개한다.

- 인터럽트 요청 신호(IRQ; Interrupt Request)
  - CPU의 작업을 방해하는 인터럽트에 대한 요청을 뜻한다.
- 인터럽트 플래그(IF; Interrupt Flag)
  - 플래그 레지스터의 인터럽트 플래그가 활성화 되어 있어야 인터럽트 요청 수행이 가능하다.
  - CPU가 중요한 작업을 처리해야 하거나 방해를 받지 않아야할 때 인터럽트 플래그는 불가능으로 설정된다.
  - 무시할 수 없는 우선순위가 높은 인터럽트도 존재, 정전이나 하드웨어 고장이 해당된다.
- 인터럽트 핸들러(IH; Interrupt Handler)
  - 각 장치마다 발생하는 인터럽트는 처리되어야 하는 방식이 다르다.
  - 장치 드라이버를 설치할 때, 인터럽트 핸들러라는 프로그램이 인터럽트 벡터 테이블(IVT; Interrupt Vector Table)에 등록된다.
  - 테이블에는 각 인터럽트 핸들러의 시작 주소가 저장되어 있으며, 이를 인터럽트 벡터라는 고유 식별 번호로 구분한다.
- 인터럽트 서비스 루틴(ISR; Interrupt Service Routine)
  - 인터럽트를 처리하기 위한 프로그램이다.
  - 인터럽트 핸들러(Interrupt Handler)라고도 부른다.
  - 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램이다.
  - 타 프로그램과 마찬가지로 명령어와 데이터로 이루어져 있다. 레지스터들을 사용하여 실행된다.
- 인터럽트 벡터(IV; Interrupt Vector)
  - 인터럽트 서비스 루틴을 식별하기 위한 정보이다.
  - 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있다.
  - 이를 통해 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있다.
  - 주변 장치가 인터럽트 요청을 보낼 때 데이터 버스로 전송한다.
  - 0-255까지의 범위를 가지는데, 0-31까지는 ISA에 의해 예약되어 있고, 32-255까지 사용자 정의 인터럽트 핸들러를 등록할 수 있다.
  - 수학적 의미의 벡터와는 아무런 관계가 없다.

![CPU의 실행 사이클](https://velog.velcdn.com/images/zenon8485/post/e3d2f41f-7e48-41c7-b555-f940bb478fe7/image.png)

#### 인터럽트 우선순위
- 인터럽트 간에는 우선순위가 있기 때문에 더 중요한 인터럽트를 먼저 처리할 수 있다.
- 우선순위가 낮은 인터럽트 서비스하는 인터럽트 핸들러는 우선순위가 더 높은 인터럽트 발생시 일시 중단될 수 있다.

#### 인터럽트 마스크
- 인터럽트에는 막을 수 있는 인터럽트(MI; Maskable Interrupt)와 막을 수 없는 인터럽트(NMI; Non Maskable Interrupt)가 있다.
- 막을 수 없는 인터럽트는 가장 우선순위가 높은 인터럽트기 때문에, 인터럽트 플래그 활성화 여부에 관계 없이 무조건 실행된다.

#### 가상 인터럽트
- 운영체제는 다른 일반 프로그램은 접근할 수 없는 하드웨어 인터럽트에 접근할 수 있다.
- 이를 기반으로 **가상 인터럽트(Virtual Interrupt)** 시스템을 제공하기도 한다.



