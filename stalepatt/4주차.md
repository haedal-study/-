# [CPU 성능 향상 기법]

## 1. 빠른 CPU를 위한 설계 기법
### 1) 클럭 속도 조절
* 클럭 신호에 따라 CPU 명령어 사이클 및 컴퓨터 부품 동작
* `클럭 속도` : 1초에 반복되는 클럭 획수(hZ 단위)
  + 오버클럭킹 : 최대 클럭 속도를 강제로 끌어 올리는 것
    - 클럭 속도 상승 시 CPU 성능 증가
    - 클럭 속도 상승 시 발열 문제 대두  

### 2) 코어 수 증가 (멀티 코어)
* `코어` = '명령어를 실행하는 부품'
  + 전통적 의미의 CPU : Core = CPU, 유일한 '명령어를 실행하는 부품'
  + 현대의 CPU : Core ⊂ CPU, 다수의 '명령어를 실행하는 부품'
    = 멀티 코어 CPU, 멀티코어 프로세서 
* 클럭 속도가 높은 싱글 코어보다 클럭 속도가 낮은 듀얼 코어가 더 좋은 성능을 보임
* 작업의 분산과 작업량이 변인으로 작용해 코어 수에 비례해서 성능이 증가하지는 않음

### 3) 스레드 수 증가 (멀티스레드 프로세서)
* `스레드(thread)` : 실행 흐름의 단위
* 스레드의 구분

  (1) 하드웨어적 스레드   
  + 하나의 코어가 동시에 처리하는 명령어 단위
  + 멀티스레드 프로세서, 멀티스레드 CPU : 하나의 코어로 여러 명령어 동시에 처리
    + 코어에 명령어 처리에 필요한 레지스터들을 여러 개 배치
    + 하이퍼스레딩 : Intel 사의 멀티스레드 기술
    + `논리 프로세서` : 프로그램 기준에서 명령어를 처리할 수 있는 프로세서의 개수, 하드웨어 스레드 각각을 CPU 하나로 인식
  
  (2) 소프트웨어적 스레드
  + 하나의 프로그램에서 독립적으로 실행되는 단위
  + 운영체제에서 관리
  
> cf. Intel 12세대 이후   
> 책의 예시에서는 4코어 CPU가 8개의 논리 프로세서를 가지는 것을 볼 수 있었습니다. 이는 각각이 하이퍼스레딩이 가능한 코어이기 때문에 코어 하나에서 2개의 명령어를 처리하면서 나타난 결과입니다.   
> 제 컴퓨터를 직접 확인해 보니 예상과 달리 코어는 14개인데 논리 프로세서가 20개임을 확인할 수 있었습니다.    
![](https://velog.velcdn.com/images/cheeeedy/post/5f8d7bb3-c0ef-4dff-96bb-8cae573e639f/image.png)   
> 왜 이런 결과가 나타났는 지 확인하기 위해 찾아보니 인텔 12세대부터는 새로운 아키텍쳐가 적용되면서 Performance Core(P-core)와 Efficient Core(E-core)의 두 가지 형태의 코어가 적용되었다고 합니다. 이러한 구조는 이미 모바일 프로세서에서는 적용된 설계 형태였지만 PC에 사용하는 인텔 CPU에서는 12세대부터 적용되었다고 합니다.   
> ![](https://velog.velcdn.com/images/cheeeedy/post/743cda54-6191-44b3-b51f-05aa7b55a98a/image.png)   
> P-core의 경우 기존의 코어와 동일하게 하이퍼스레딩이 가능하고, E-core의 경우 하이퍼스레딩이 적용되지 않는 대신 전력 효율이 좋다고 합니다. 이 때문에 제 PC의 경우 논리 프로세서가 P-core에서 6\*2 = 12개 + E-core에서 8개 총 20개였습니다.
> 
> 위와 같은 특징 때문에 게임 엔진 개발 시 [GPU에게 빠르게 연산 결과를 주고 받아야하는 렌더링 작업은 P-core에, 비동기적으로 실행되는 작업을 E-core에서 처리하도록 설계한다면 CPU 부하를 줄일 수 있다](https://www.intel.com/content/www/us/en/developer/articles/guide/12th-gen-intel-core-processor-gamedev-guide.html?wapkw=e-core%20p%3Dcore#inpage-nav-5-4)고 합니다.   
 

## 2. 명령어 병렬 처리 기법
> ILP, Instruction-Level Parallelism   

### 1) 명령어 파이프라인(instruction pipeline)
* 명령어 파이프라이닝(instruction pipelining) : 명령어 처리 과정을 명령어 파이프라인에 넣고 동시에 겹쳐서 처리하는 기법
  + 명령어 처리 과정의 예
  >(1) 명령어 인출
  >(2) 명령어 해석
  >(3) 명령어 실행
  >(4) 결과 저장

* 파이프라인 위험 : 명령어 처리를 파이프라인에 의해 동시에 진행하면서 발생하는 위험 요소 및 그로 인한 성능 향상에 실패    

  (1) 데이터 위험   
    + 명령어 간의 의존성으로 인해 발생   
  (2) 제어 위험   
    + 프로그램 카운터의 갑작스러운 변화 (실행 흐름 변화)
    + 분기 예측(branch prediction)을 통해 예방   
  (3) 구조적 위험   
    + 서로 다른 명령어가 같은 CPU 자원을 사용하려는 경우   
    = 자원 위험(resource hazard)

### 2) 슈퍼스칼라(superscalar)
* CPU 내부에 여러 개의 명령어 파이프라인을 포함하는 구조
* 매 클럭 주기마다 동시에 여러 명령어 인출, 실행 등의 절차 수행 가능
* 파이프라인 위험 등의 문제로 처리 속도가 파이프라인 개수에 비례하여 증가하지 않음

### 3) 비순차적 명령어 처리(OoOE, Out of Oreder Execution)
* 명령어를 순차적으로 실행하지 않는 기법
* 서로 데이터 의존성이 없는 (결과에 영향을 미치지 않는) 명령어를 뒤의 명령어와 순서를 바꾸어 실행
  * 지연으로 인한 파이프라인이 멈추는 것을 방지

## 3. CISC와 RISC
### 1) 명령어 집합
* 명령어 집합 구조(ISA, Instruction Set Architecture) : CPU가 해석 가능한 형태의 이진 코드로 구성되는 실제 컴퓨터를 동작시킬 수 있는 명령어 모음
* 명령어의 차이에 따른 어셈블리어에도 차이 발생
  + 같은 소스 코드로 이루어진 프로그램이라도 ISA에 따라 서로 다른 어셈블리어 형태를 갖게 됨
  + 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법에도 차이 발생

### 2) CISC
* Complex Instruction Set Computer
* 다양하고 강력한 기능의 명령어 집합을 활용
* `가변 길이 명령어` 사용
  + 주소 지정 방식 및 특별한 상황에만 사용 가능한 다양한 명령어 형태 존재
  + 상대적으로 적은 수의 명령어로 프로그램 실행 가능
  + 제한된 메모리 내에서 개발 시 용이
  + 명령어 크기와 실행되기까지의 시간이 일정하지 않음
    - 규격화되지 않은 명령어로 인해 효율적인 파이프라인 구현이 어려움
    
### 3) RISC
* Reduced Instruction Set Computer
* CISC 명령어 집합에서 실제 사용되는 명령어의 비율이 낮은 문제를 발견
* `고정 길이 명령어` : 명령어 파이프라이닝에 최적화된 형태
  + 자주 쓰이는 기본적인 명령어를 작고 빠르게 만듬
  > ex. RISC 명령어 집합에서 메모리에 직접 접근하는 명령어를 Load, Store 두 개로 제한 (load-store architecture)
  + 1클럭 내외로 실행되는 명령어 지향
  + CISC에 비해 적은 주소 지정 방식
  + 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극적으로 활용

---
참고자료

[📚강민철, 『혼자 공부하는 컴퓨터 구조 + 운영체제』, 한빛미디어, 2022.](https://www.hanbit.co.kr/store/books/look.php?p_code=B9177037040)   
[📹유튜브 공식 강의 12, 13, 14강](https://youtu.be/VO0RQAA7KYc?si=yiU4zxFDD0SHrQMs)   
[🐈‍⬛책 부록 GitHub](https://github.com/kangtegong/self-learning-cs)   
[🖥️ Game Dev Guide for 12th Gen Intel® Core™ Processor](https://www.intel.com/content/www/us/en/developer/articles/guide/12th-gen-intel-core-processor-gamedev-guide.html?wapkw=e-core%20p%3Dcore)   