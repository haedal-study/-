# Chapter 5 : CPU 성능 향상 기법

## 5.1. 빠른 CPU를 위한 설계 기법

### 5.1.1. 클럭(clock)
- 컴퓨터 부품들은 클럭 신호에 맞춰 동작한다.
- 따라서 클럭 속도가 높은 CPU는 일반적으로 성능이 좋다.
- 클럭 속도는 헤르츠(Hz) 단위로 측정하는데, 이는 1초에 클럭이 몇 번 반복되는지를 나타낸다.
- 클럭 속도를 높이는 것 만으로 CPU 성능 향상에는 한계가 있다.
  - 높은 클럭 속도가 발열과 전력 소모를 증가시켜, 안정성에 문제를 초래할 수 있기 떄문이다.
- 클럭 속도는 일정하지 않다. 기본(Base)과 최대(Max)로 나뉘어져 있다.
- 최대 클럭 속도를 강제로 끌어올릴 수 있는데, 이를 **오버클럭킹(Overclocking)** 이라 한다.

### 5.1.2. 코어와 멀티코어

![전통적인 CPU, 오늘날의 CPU](https://velog.velcdn.com/images/mmodestaa/post/67af8923-3f72-4943-b82b-6e14bc1f0d42/image.png)

- CPU의 성능을 높이는 방법에는 CPU의 코어와 스레드 수를 늘리는 방법이 있다.
- 전통적인 의미에서 CPU는 '명령어를 실행하는 부품'을 뜻한다.
- 오늘날에는 CPU 내부에 명령어를 처리할 부품이 여러개 존재할 수 있는데, 이러한 부품을 **코어(Core)** 라고 부른다.
- 코어를 여러개 포함한 CPU를 **멀티코어 CPU** 또는 **멀티코어 프로세서** 라 부른다.
- 코어가 많아도 연산 속도가 비례해서 증가하지는 않는다. 처리할 연산이 적절하게 분배되어야 효율적인 성능 향상이 이루어진다.

### 5.1.3. 스레드와 멀티스레드
- 스레드의 사전적 의미는 '실행 흐름의 단위' 이다.
- CPU에서 사용되는 '하드웨어적 스레드'와 프로그램에서 사용되는 '소프트웨어적 스레드'가 존재한다.

#### 하드웨어적 스레드
- 하나의 코어가 동시에 처리하는 명령어 단위이다.
  - 여러 스레드를 지원하는 CPU는 하나의 코어로도 여러 개의 명령어를 동시에 실행할 수 있다.
  - 이러한 CPU를 **멀티스레드 프로세서** 또는 **멀티스레드 CPU** 라 한다.
  - **논리 프로세서** 라고 부르기도 한다.
- 멀티스레드 프로세서의 핵심은 레지스터이다.
  - 하나의 코어로 여러 명령어를 처리하기 위해서는 꼭 필요한 레지스터를 여러개 지니면 된다.
  > 예시
  > - 프로그램 카운터가 두 개 있다면 메모리에서 가져올 명령어 주소를 두 개 지정할 수 있다.
  > - 스택 포인터가 두 개 있다면 두 개의 스택을 관리할 수 있다.

![2코어 4스레드 CPU](https://velog.velcdn.com/images/mmodestaa/post/025f1fc8-07a9-4e21-a69a-97df5e55ace7/image.png)

![작업 관리자 논리 프로세서](https://i0.wp.com/triki.net/wp-content/uploads/2019/10/windows10-check-core-and-thread.png?w=1134)

- 위 그림은, 메모리 속 프로그램이 보기에는 한 번에 하나의 명령어를 처리하는 부품이 여덟 개로 나오는 것.
  - 4코어 8스레드의 경우 위와 같은 작업 관리자처럼 나오게 된다.

#### 소프트웨어적 스레드
- 하나의 프로그램에서 독립적으로 실행되는 단위를 의미한다.
- 하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수 있지만, 여러 부분이 동시에 실행될 수 있다.

## 5.2. 명령어 병렬 처리 기법
- 명령어 병럴 처리 기법(ILP; Instruction-Level Parallelism)
  - 하나의 프로세서가 여러 개의 명령어를 동시에 실행할 수 있도록 설계하는 기법
  - 하나의 클럭 사이클에 여러 개의 연산을 수행하려는 목적으로 사용된다.
- 대표적인 명령어 처리 기법
  - 명령어 파이프라이닝(Instruction Pipelining)
  - 슈퍼스칼라(Superscalar)
  - 비순차적 명령어 처리(OoOE; Out-of-Order Execution)

### 5.2.1. 명령어 파이프라인
- 명령어 처리 과정을 클럭 단위로 나눈다면, 일반적으로 다음과 같다.
  - 명령어 인출(Instruction Fetch)
  - 명령어 해석(Instruction Decode)
  - 명령어 실행(Execute Instruction) 
  - 결과 저장(Write Back)
- 핵심은 단계가 겹치지 않는다면, CPU는 각 단계를 동시에 실행할 수 있다라는 점.
  > 예시
  > - 명령어 A, B, C, D가 있을 때.
  > - CPU는 A를 인출 하면서 B를 해석 할 수 있고, 그러면서 C를 실행하며 D를 저장할 수 있다.
- 명령어들을 명렁어 **파이프라인(Instruction Pipeline)** 에 넣고 동시에 처리하는 기법을 **명령어 파이프라이닝(Instruction Pipelining)** 이라고 한다.

![명령어 파이프라인](https://velog.velcdn.com/images/mmodestaa/post/54cc70da-79e7-47e0-b8fd-43b3c761f558/image.png)

- 하지만 특정 상황에서는 성능 향상에 실패할 수 있다.
- 이를 **파이프라인 위험(Pipeline Hazard)** 라고 하며, 세 종류가 존재한다.
  - 데이터 위험(Data Hazard)
  - 제어 위험(Control Hazard)
  - 구조적 위험(Structural Hazard)

#### 데이터 위험
- 명령어간 데이터 의존성에 의해 발생한다.
- 어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로소 실행할 수 있는 경우가 있다.
  > 예시
  > - 명령어 1 : R1 <= R2 + R3
  > - 명령어 2 : R4 <= R1 + R5
  > - 이 때 2는 1의 데이터에 의존적이다.
- 의존적인 두 명령어를 동시에 실행하려고 할 때 파이프라인이 제대로 작동하지 않는 것을 의미한다.

#### 제어 위험
- CPU가 미리 다음 명령어를 준비하는데, 분기나 루프 때문에 그 다음 명령어가 뭔지 확실하지 않을 때 발생하는 지연이다.
- > 예시
  > - 만약 A라면 B해라 라는 조건문이 있을 때, A인지 아닌지 확인하기 전 까지는 B가 실행되어야 하지 말아야 할지 CPU는 알 수 없다.
  > - CPU가 미리 다음 명령어를 가져와서 실행하려고 했다가 조건에 따라 다른 명령어를 실행해야 하는 상황이 발생할 수 있다.
  > - 이 때, 미리 가져온 명령어를 취소하고 새로운 명령어를 가져오는데, 이 때 지연이 발생한다.

#### 구조적 위험
- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려 할 때 발생한다.
- 자원 위험(Resource Hazard) 라고도 부른다.

### 5.2.2. 슈퍼스칼라
- 오늘날의 대부분의 CPU에서는 여러 개의 파이프라인을 이용한다.
- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 **슈퍼스칼라** 라고 한다.

![슈퍼스칼라](https://velog.velcdn.com/images/mmodestaa/post/46c1c33d-8284-472e-a2fc-6abd125d32da/image.png)

- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 **슈퍼스칼라 프로세서** 또는 **슈퍼스칼라 CPU** 라고 한다.
- 이론적으로 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라진다.
- 파이프라인의 개수가 늘어나기 때문에 파이프라인 위험을 효과적으로 관리해야한다.

### 5.2.3. 비순차적 명령어 처리
- 오늘날 CPU 성능 향상에 크게 기여한 기법이며, 대부분의 CPU가 차용하는 기법.
- 파이프라이닝과 슈퍼스칼라는 명령어의 순차적인 처리를 상정한 기법.
- 비순차적 명령어 처리는 파이프라인의 중단을 방지하기 위해 병렬로 처리하는 기법이다.

![비순차적 명령어 처리 1](https://velog.velcdn.com/images/mmodestaa/post/395e34e8-9ebd-4c7c-a7a9-82c6441ae82e/image.png)
![비순차적 명령어 처리 2](https://velog.velcdn.com/images/mmodestaa/post/92596d69-fb84-4019-924f-e10cb04876f9/image.png)

> 예시
> - 윗 그림에서 3번의 과정 때문에 명령어를 순서대로 실행하는 파이프라이닝을 활용할 수 없음.
> - 의존성이 없는 명령어의 순서를 바꿔서 파이프라이닝을 최대로 활용할 수 있음.

- 아무 명령어나 순서를 바꿀 수 있는 것은 아니며, 전체 프로그램 실행 흐름에 영향이 없는 경우에만 가능하다.

## 5.3. CISC와 RISC
- ISA(Instruction Set Architecture) : 프로세서가 이해할 수 있는 명령어 집합과 기계어 형식, 레지스터 구조, 입출력 방법 등을 정의한 인터페이스
  - 소프트웨어와 하드웨어가 상호 작용하는 방법을 설명하는 '규칙 집합' 이라 볼 수 있다.
- 각기 다른 성격의 ISA를 기반으로 설계된 **CISC** 와 **RISC** 가 존재한다.

### 5.3.1. 명령어 집합(Instruction Set)
- 명령어의 세세한 생김세, 명령어로 할 수 있는 연산, 주소 지정 방식은 CPU마다 차이가 있다.
- CPU가 이해할 수 있는 명령어들의 모음을 **명령어 집합** 이라 한다.
- **명령어 집합 구조(ISA; Instruction Set Architecture)** 라고도 한다.
- 정리하자면, ISA가 다르면 CPU가 이해할 수 있는 명령어도, 명령어를 읽기 편하게 표현한 어셈블리어도 달라진다.

![ISA에 따른 어셈블리어의 차이](https://velog.velcdn.com/images/heyksw/post/b1aeb4cb-f0c8-45eb-9c11-6d1dd478b8aa/image.png)

### 5.3.2. CISC(Complex Instruction Set Computer)
- 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식이다.
- 명령어의 형태와 크기가 다양한 **가변 길이 명령어** 를 활용한다.
- 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다.
  - 프로그램을 실행하는 명령어 수가 적다는 말은 '컴파일된 프로그램의 크기가 작다'는 것을 의미한다.
  - 즉, 같은 소스 코드를 컴파일해도 CPU마다 생성되는 실행 파일의 크기가 다를 수 있다.
- 적은 수의 명령어만으로도 프로그램을 동작시킬 수 있다는 것은 메모리 공간을 절약할 수 있다는 의미이다.
- 단점 
  - 명령어의 크기와 실행되기까지 시간이 일정하지 않다는 점이 있다.
    - 때문에 명령어 파이프라이닝을 어렵게 만든다.
    - 이는 약점으로 작용할 수 있는데, 현대 CPU에서 명령어 파이프라인은 높은 성능을 내기 위한 핵심 기술이기 때문.
  - 대다수의 복잡한 명령어는 사용 빈도가 낮다.

### 5.3.3. RISC(Reduced Instruction Set Computer)
- CISC의 한계로 얻을 수 있는 교훈은 다음과 같다.
  - 빠른 처리를 위해 명령어 파이프라인을 활용해야 하는데, 이를 위해 명령어 길이와 수행 시간이 짧고 규격화 되어 있어야 한다.
  - 복잡한 기능을 지원하는 명령어를 추가하기보다 자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것이 중요하다.
- 이런 원칙 하에 등장한 명령이 집합이 **RISC** 이다.
- CISC에 비해 명령어의 종류가 적고, 되도록 1클럭 내외로 실행되는 규격화된 명령어를 지향한다.
  - 즉, 고정 길이 명령어를 활용한다.
- 또한 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한하여 메모리 접근을 단순화하고 최소화를 추구한다.
  - 이런 점에서 RISC를 **load-store 구조** 라고 부르기도 한다.
- RISC 는 레지스터를 적극적으로 사용한다.
  - CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많다.
  - 다만 명령어 개수가 CISC보다 적기 때문에, RISC는 CISC보다 많은 명령어를 사용하여 프로그램을 작동시킨다.

### 정리

![CISC와 RISC](https://velog.velcdn.com/images/mmodestaa/post/cd53cfaf-3e39-4e6d-9f4f-841dbedf2646/image.png)