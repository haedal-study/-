# 4. CPU의 작동 원리
## ALU와 제어장치

### ALU
- ALU는 CPU 내에서 계산을 담당하는 부품이다. 
- 계산을 하기 위해서는 피연산자와 수행할 연산이 필요하다.
- ALU의 동작 과정
    - 레지스터를 통해 피연산자를 받아들인다.
    - 제어장치로부터 수행할 연산을 받아들인다.
    - 연산을 수행한 결과를 일시적으로 레지스터에 저장한다.
    - 연산 결과의 추가적인 정보를 가지고 있는 플래그를 플래그 레지스터에 저장한다.

- 플래그의 종류
    - 부호 플래그: 연산 결과의 부호를 나타낸다.
    - 제로 플래그: 연산 결과가 0인지 여부를 나타낸다.
    - 캐리 플래그: 올림수나 빌림수가 있는지 여부를 나타낸다.
    - 오버플로우 플래그: 오버플로우가 발생했는지를 나타낸다.
    - 인터럽트 플래그: 인터럽트가 가능한지를 나타낸다.
    - 슈퍼바이저 플래그: 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다.
    
![스크린샷 2023-08-16 오후 9.33.12](https://i.imgur.com/hHN2iuZ.png)

위의 이미지처럼 1과0으로 플래그를 나타낸다.

### 제어장치
- 제어장치는 제어신호를 내보내고, 명령어를 해석하는 부품
- 제어신호는 컴퓨터 부품들을 제어하는 전기 신호

#### 제어장치가 받아들이는 정보
1. 클럭 신호
    - 컴퓨터의 부품을 움직이게 하는 시간 단위

2. 해석해야 할 명령어
    - 명령어 레지스터로부터 해석할 명령어를 받아들인다.
    - 명령어를 해석한 뒤, 컴퓨터 부품들에 제어 신호를 보낸다.

3. 플래그
    - 플래그 값을 참고하여 제어 신호를 발생시킨다.

4. 제어 신호
    - 제어 버스로 전달된 제어 신호를 받아들인다.

#### 제어장치가 내보내는 정보
1. CPU 외부에 전달하는 제어 신호
    - 제어 버스를 통해 저장된 값을 읽거나 쓰고 싶을 때 메모리와 입출력장치에 제어 신호를 전달한다.
2. CPU 내부에 전달하는 제어 신호
    - ALU에 수행할 연산을 지시하기 위해 제어 신호를 전달한다.
    - 레지스터에 레지스터 간에 이동과 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 내보낸다.

## 레지스터
CPU는 종류에 따라서 가지고 있는 레지스터가 다르지만 많은 CPU가 공통으로 포함하고 있는 레지스터는 다음과 같다.
1. 프로그램 카운터
    - 명령어가 저장된 주소를 저장한다.
2. 명령어 레지스터
    - 메모리에서 불러온 명령어를 저장한다.
3. 메모리 주소 레지스터
    - CPU가 읽어 들이고자 하는 주소값이 저장된다.
    - 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다.
4. 메모리 버퍼 레지스터
    - 메모리에 저장된 값을 불러오거나, 메모리에 쓰는 값이 저장된다.
    - 데이터 버스로 주고받을 값이 메모리 버퍼 레지스터를 거친다.
5. 범용 레지스터
    - 데이터와 주소를 모두 저장할 수 있다.
6. 플래그 레지스터
    - 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장한다.
7. 스택 포인터
    - 스택 주소 지정 방식에 사용된다.
        - 스택과 스택 포인터를 이용한 주소 지정 방식.
    - 스택의 꼭대기를 가리킨다.

8. 베이스 레지스터
    - 변위 주소 지정 방식에 사용된다. 상대 주소 지정 방식과 베이스 레지스터 주소 지정 방식으로 나뉜다.
        - 상대 주소 지정 방식
            - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식

            ![스크린샷 2023-08-17 오후 6.03.16](/assets/스크린샷%202023-08-17%20오후%206.03.16.png)

        - 베이스 레지스터 주소 지정 방식
            - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식 
            - 베이스 레지스터는 기준 주소, 오퍼랜드는 기준 주소로부터 떨어진 거리의 역할을 한다.

![스크린샷 2023-08-17 오후 6.02.25](/assets/스크린샷%202023-08-17%20오후%206.02.25.png)

## 명령어 사이클과 인터럽트

### 명령어 사이클
명령어 사이클은 CPU가 명령어를 일정한 주기가 반복되며 실행되는 것을 말한다. 인출 사이클과 실행 사이클을 반복하는데 인출 사이클은 메모리에 있는 명령어를 CPU로 가지고 오는 단계를 말하며 실행 사이클은 CPU로 가지고 온 명령어를 실행하는 단계를 말한다. 인출 사이클 이후에 바로 실행 사이클로 넘어갈 수도 있지만 메모리 접근이 더 필요한 경우 간접 사이클을 거친 후 실행 사이클로 넘어간다. 

### 인터럽트
사이클 중간에 끼어들어서 잠시 중단시키는 신호를 말한다. CPU가 꼭 알아야 하는 작업이나 우선순위가 높은 작업이 생겼을 때 발생한다.

#### 동기 인터럽트(예외)
CPU가 예상치 못한 상황을 마주했을 때 발생한다. 예를 들어 디버깅할 때나 프로그램 오류와 같은 상황이다.

#### 하드웨어 인터럽트(하드웨어 인터럽트)
입출력 장치에 의해 발생하는 신호로써, 알림과 같은 역할을 한다. 예를 들어 마우스로 클릭해서 CPU에 요청하는 상황이 될 수 있다. 인터럽트는 입출력 장치의 작업이 완료됐는지 계속해서 검사하지 않아도 완료됐을 때 CPU에 알림을 보냄으로써 CPU가 다른 작업을 할 수 있게 한다.

> - 하드웨어 인터럽트의 처리 순서
> 1. 입출력 장치는 CPU에 인터럽트 요청 신호를 보낸다. 
> 2. CPU는 실행 사이클이 끝나고 인출 사이클 전에 인터럽트 요청이 있나 검사한다.
> 3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 인터럽트를 받아들일 수 있는 상태인지 확인한다.
> 4. 인터럽트를 받아들일 수 있다면 작업한 내용을 백업한다.
> 5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.
> 6. 인터럽트 서비스 루틴이 끝나면 백업해둔 내용을 불러와서 재개한다.
![스크린샷 2023-08-17 오후 6.58.02](/assets/스크린샷%202023-08-17%20오후%206.58.02.png)
![스크린샷 2023-08-17 오후 6.59.41](/assets/스크린샷%202023-08-17%20오후%206.59.41.png)
> 스택 영역에 백업 내용을 저장한다.

#### 인터럽트 관련 용어
- 인터럽트 요청 신호: 인터럽트를 발생시켜도 되는지 CPU에 묻는 신호
- 인터럽트 플래그: 플래그 레지스터의 인터럽트 플래그를 말한다. 인터럽트를 받을 수 있는 상태라면 1로 표시된다.
![스크린샷 2023-08-17 오후 7.01.06](/assets/스크린샷%202023-08-17%20오후%207.01.06.png)

*모든 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니다. 중요하고 긴급한 인터럽트는 막을 수 없다. 막을 수 있는 인터럽트는 maskable interrupt, 막을 수 없는 인터럽트는 non mask interrupt라고 한다.

- 인터럽트 서비스 루틴: 인터럽트를 처리하기 위한 프로그램을 말한다.
    - 프로그램이기 때문에 메모리에 저장된다.

![스크린샷 2023-08-17 오후 7.03.03](/assets/스크린샷%202023-08-17%20오후%207.03.03.png)

- 인터럽트 벡터: 인터럽트를 보내는 주체에 따라서 인터럽트 서비스 루틴이 다르다. 즉 메모리에 저장된 인터럽트 서비스 루틴의 시작 주소가 다르다. 그래서 각각의 인터럽트 서비스 루틴을 구분하기 위한 정보가 인터럽트 벡터이다.

![스크린샷 2023-08-17 오후 7.03.33](/assets/스크린샷%202023-08-17%20오후%207.03.33.png)

위의 이미지는 인터럽트 사이클까지 추가된 명령어 사이클이다.

